# Laravel Framework Documentation
was made according to self-improvement spreadsheet

Рекомендую курсы:
Max Orlov - Laravel
Cutcode - Laravel

App structure - 15 row
Routes - 226 row
Controllers - 417 row
Middlewares - 504 row
Views - 617 row
Models - 713 row
Service Provider - 1157
Jobs, Queue - 1338

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                           App structure
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
app {
    Весь основной код приложения
    Console {
        Все что необходимо для обработки commands (стандартных и кастомных)
        Kernel.php {
            Регистрация кастомных commands
        }
    }
    Events {
        Входит в раздел слушатели и события. Слушатели и события объявляются в EventServiceProvider.php
    }
    Http {
        Controllers {
            Обработка запросов на отображение, создание, обновление и удаление пользователей
        }
        Middleware {
            MIDDLEWARE - ПРОМЕЖУТОЧНЫЙ СЛОЙ МЕЖДУ ВХОДЯЩИМ ЗАПРОСОМ И КОНТРОЛЛЕРОМ
            Можно записать логи, добавить к ответу файлы куки и т.п.
            Authenticate - вошел пользователь или не вошел
            EncryptCookies - когда запрос с куками прилетает в наше приложение - он расшифровывает их, а на выходе - шифрует
            PreventRequestsDuringMaintenance - находится ли наше приложение в режиме обслуживания при каком-либо запросе
            php artisan down - включает режим обслуживания
            RedirectIfAuthenticated - если юзер уже вошел в систему - перекидывает в личный кабинет
            TrimStrings - если была отправлена форма регистрации, может быть такое что юзер прислал email с пробелом в конце,
            этот middleware обрезает пробелы в начале и в конце полей
            TrustHosts - хосты с которыми будет взаимодействовать приложение
            TrustProxies - сервер-балансировщик распределяет все запросы поровну на сервера приложения
            VerifyCsrfToken - защита от Csrf атаки (подделка межсайтовых запросов). Нужно соблюдать его при использовании форм
            POST, PUT, DELETE | @csrf
        }
        Requests {
            Другая форма для правил валидации. Чтобы не писать логику валидации в контроллере - можем создать отдельный класс, в котором в методе
            "rules" будут перечислены правила валидации
        }
        Kernel.php {
            Все что необходимо для обработки HTTP запросов
            Настройка middleware - классов которые обрабатывают запрос, прежде чем он попадает в контроллер
        }
    }
    Jobs {
        Создание jobs
    }

    Listeners {
        Слушатели событий, объявляются в EventServiceProvider.php
    }
    Mail {
        При запуске команды php artisan make:mail {name}. Служит для отправки уведомлений на почту
    }
    Models {
        Модели приложения, с помощью которых можно задать конфигурацию на относящийся к ним таблицы и взаимодействовать с ними
    }
    Providers {
        Системные конфигурируемые настройки
        AppServiceProvider {
            В методе "boot" можно задать настройки для вьюх и т.д.
        }
        EventServiceProvider {
            Регистрация слушателей и событий
        }
        RouteServiceProvider {
            Можно задать новые пути для рутов, если мы хотим разделить их на несоклько файлов
        }
    }
    Rules {
        Можно задать дополнительные правила валидации, которые потом сможем использовать в контроллере или в Requests
    }
    Scopes {
        Можно задать условии, по котором при обращении к модели будут браться определенные данные (например при запросах SELECT, UPDATE, DELETE)
    }
}

bootstrap {
    app.php {
        Главный файл по запуску приложения. С этого файла начинается работа всего фреймворка
        В переменную $app кладется экземпляр самого приложение, регистрируется HTTP и консольные ядра
        Возвращается экземпляр приложения
    }
    cache {
        Этот каталог входит в gitignore, там фреймворк делает какие-то свои операции, которые не будут видны в репозитории
    }
}

config {
    Просто множество файлов конфигурации
    Можно создавать свои файлы конфигурации
}

database {
    Создаются файлы для работы с базой данных
    factories {
        Содержится конфиг для сидинга базы данных
    }
    migrations {
        Миграции к базе данных
    }
    seeders {
        Сиды для базы данных, которые используют фабрики
    }
}

lang {
    Содержит настройку по языку проекта
}

public {
    Содержит в себе публичные файлы
    Все запросы которые приходят от браузера должны попадать в файл index.php
    Берем HTTP ядро и запускаем обработку запроса.
}

resources {
    css, js {
        Исходные стили для страничек
    }
    views {
        Все странички сайта
        components {
            Работает как интерфейсы в ООП, только с небольшой реализацией и начальными параметрами
        }
    }
}

routes {
    Можно создавать свои файлы для маршрутизации
    api.php {
        Маршруты для API
    }

    console.php {
        Мы можем создавать свои команды, но лучше это делать с помощью php artisan make:command <> -> тогда этот файла попадет
        в app/Console/Command
    }

    channels.php {
        Позволяет регистрировать каналы, проверять доступы пользователей к тому или иному каналу
    }

    web.php {
        Маршруты для браузера
    }
}

storage {
    app {
        public {
            Если пользователь загружает аватарку - она попадает сюда
        }
    }

    framework {
        Закэшированные шаблоны для оптимизации
    }

    logs {
        Если возникает какая-то ошибка - можно поискать и найти ее там
    }
}

tests {
    Юнит и Фича тесты
}

vendor {
    Пакеты и зависимости композера
    Исходный код фреймворка в поддиректории laravel
}

.editorconfig {
    Параметры для редактора кода
}

.env {
    Добавлен в .gitignore, переменная окружения
}

.env.example {
    Его нет в .gitignore, это просто шаблон .env
}

.gitignore {
    Добавляем файлы в .gitignore
}

artisan {
    Когда мы выполняем команду php artisan... берем app.php, берем консольное ядро Kernel и обрабатываем команду
}

AboutFiles.txt {
    То что ты читаешь сейчас --__--
}

composer.json {
    Перечислены все пакеты которые нужны для работы нашего проекта
}

composer.lock {
    Фиксирование тех зависимостей и версий которые у нас остановлены
}

package.json {
    Для пакетов которые установлены через npm
}

phpunit.xml {
    Параметры для тестирования
}

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Artisan console
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Artisan это не имя таксиста, это Laravel, детка. © Daniil Boyko

-----------------------------------------------------------------------------------------------------------
Базовые понятия
-----------------------------------------------------------------------------------------------------------
Artisan - интерфейс командной строки, входящий в состав Laravel.
Для просмотра всех действующих команд:
    php artisan list

Каждая команда включает в себя экран "справки", где отображены документы и параметры команды. Используем:
    php artisan help migrate

Laravel Tinker - мощный REPL для фреймворка Laravel. Что такое REPL? Read, Eval, Print, Loop.
Он и так установлен в Laravel по умолчанию, но если мало ли он удален:
Чтобы установить Tinker:
    composer require laravel/tinker

Теперь поговорим о том как этим пользоваться. Чтобы запустить:
    php artisan tinker

Честно, я не особо пользовался Laravel Tinker, но возможно это удобный инструмент для начала разработки проекта.

Конфигурационный файл tinker может быть опубликован командой:
    php artisan vendor:publish --provider="Laravel\Tinker\TinkerServiceProvider"

-----------------------------------------------------------------------------------------------------------
Custom commands
-----------------------------------------------------------------------------------------------------------
Можно создавать кастомные команды. Например, в sxope-ocean это pipeline:run, либо bq_to_spanner, send_flush_cache и другие.
Чтобы создать кастомную команду:
    php artisan make:commands SendEmails

После создания команды следует заполнить свойства $signature - это слова по которым команда будет запускать (bq_to_spanner:load, pipeline:run),
а также свойство $description - краткое описание команды.

По умолчанию, при вызове этой команды будет исполняться метод handle(). С помощью service-container, Laravel внедрит все необходимые зависимости,
типы которых объявлены в этом методе:
    namespace App\Console\Commands;

    use App\Models\User;
    use App\Support\DripEmailer;
    use Illuminate\Console\Command;

    class SendEmails extends Command
    {
        /**
         * Имя и сигнатура консольной команды.
         *
         * @var string
         */
        protected $signature = 'mail:send {user}';

        /**
         * Описание консольной команды.
         *
         * @var string
         */
        protected $description = 'Send a marketing email to a user';

        /**
         * Создать новый экземпляр команды.
         *
         * @return void
         */
        public function __construct()
        {
            parent::__construct();
        }

        /**
         * Выполнить консольную команду.
         *
         * @param  \App\Support\DripEmailer  $drip
         * @return mixed
         */
        public function handle(DripEmailer $drip)
        {
            $drip->send(User::find($this->argument('user')));
        }
    }

Хорошей практикой является делать максимально простые консольные команды с делегированием своих задач службам приложения.
Дальше пойдут Action classes, туда надо помещать всю основную логику, но об этом потом. Пока ради практики можете помещать логику прям в handle().

-----------------------------------------------------------------------------------------------------------
Анонимные команды
-----------------------------------------------------------------------------------------------------------
В рамках метода commands() файла App/Console/Kernel.php Laravel загружал файл routes/console.php.
    /**
     * Зарегистрировать команды, основанные на анонимных функциях.
     *
     * @return void
     */
    protected function commands()
    {
        require base_path('routes/console.php');
    }
Далее можно определить все анонимные консольные команды. Метод command применяет два аргумента: сигнатуру команды и замыкание
    Artisan::command('mail:send {user}', function ($user) {
        $this->info("Sending email to: {$user}!");
    });

Пользуясь контейнером служб, можно внедрять зависимости:
    use App\Models\User;
    use App\Support\DripEmailer;

    Artisan::command('mail:send {user}', function (DripEmailer $drip, $user) {
        $drip->send(User::find($user));
    });

При определении анонимных команд, можно использовать метод purpose. Это описание будет отображаться в списке php artisan list.
    Artisan::command('mail:send {user}', function ($user) {
        // ...
    })->purpose('Send a marketing email to a user');

-----------------------------------------------------------------------------------------------------------
Определение вводимых данных
-----------------------------------------------------------------------------------------------------------
Что такое вводимые данные?
    $signature = 'mail:send {user}'; {user} - это вводимые данные. Условно, это как например флаг --isAutoLoadDisabled, тоже вводимые данные.
Если аргумент необязательный, то пишем {user?}
А вот так пишется аргумент со значением по умолчанию, но я думаю это bad pattern.
    $signature = mail:send {user=foo}

Аргументы-флаги, которые обозначаются в командах (как --isAutoLoadDisabled) называют переключателями.
    $signature = 'mail:send {user} {--queue}';
Если при вызове команды был написан --queue, то он будет true, если нет - то false.

Если при вызове команды должно быть указано значение для параметра - то пишем:
    $signature = 'mail:send {user} {--queue=}'
Если параметр не указан при вызове команды, то его значение будет null.
    php artisan mail:send 1 --queue=default

Чтобы назначить псевдоним, по-другому - алиас, при определении параметра, можно указать его перед имененем параметра вот так:
    $signature = mail:send {user} {--Q|queue};

Если хотим передать больше одного значения в вводимые данные, пишем:
    $signature = mail:send {user*}
И тогда запуск:
    $signature = mail:send foo bar

Можно комбинировать:
    $signature = mail:send {user?*}

Описание вводимых данных:
    $signature = 'mail:send
                  {user : The ID of the user}'

Как получать значения вводимых данных? Вот так:
    public function handle()
    {
        $userId = $this->argument('user');
    }

Если их несколько, то можно получить целый массив параметров:
    public function handle()
    {
        $userId = $this->arguments();
    }

Либо:
    public function handle()
    {
        $queueName = $this->option('queue');
    }

Ну и также:
    public function handle()
    {
        $queueName = $this->options();
    }


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                                  Routes
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Руты это не рут права на андроиде при взламывании игр. © Daniil Boyko

Пример route с callback функцией:
    Route::get('/hello', function() {
        return 'Hello World';
    });
Следовательно, после перехода в браузере на url: 127.0.0.1:8000/hello - мы увидим надпись Hello World.

По умолчанию все routes находятся в файле routes/web.php
Мы можем зарегистрировать новый файл в RouteServiceProvider.php
    Route::middleware('web')
        ->group(function() {
            require base_path('routes/web.php');
            require base_path('routes/admin.php');
            require base_path('routes/user.php');
        });
О страшном слове middleware позже.

-----------------------------------------------------------------------------------------------------------
Routes types:
    Route::get('url', 'function');
    Route::post('url', 'function');
    Route::put('url', 'function');
    Route::patch('url', 'function');
    Route::delete('url', 'function');
    Route::options('url', 'function');
-----------------------------------------------------------------------------------------------------------
GET метод позволяет получить все то, что нельзя никак отредактировать, добавить, удалить и так далее (к примеру HTML странички)
POST - может использоваться также для редактирования ресурса
PUT - для редактирования ресурса
DELETE - удаление ресурса
OPTIONS - представляет запрос информации об опциях соединения, доступных в цепочке запросов/ответов (короче конфиг)

Вроде с помощью POST можно редактировать какую-то запись и с помощью PUT, так в чем же разница?
    Представь, что у нас есть сервис с блогом и постами. В одном блоге может быть несколько постов.
    Для добавления нового поста мы конечно используем метод POST с url например: domain.com/blogs/id
    После создания нового поста метод POST сам создаст URL и вернет этот URL для доступа к нему через GET или для удаления через DELETE

    А теперь допустим, что такой пост уже создан и клиент хочет просто отредактировать его (исправить синтаксическую ошибку например)
    То есть другими словами, клиент хочет ПЕРЕЗАПИСАТЬ пост
    Для этого будет использован метод PUT с URL: domain.com/blogs/id/posts/post_id, он передает обновленную запись в теле запроса
    Сервис, ориентируясь на метод PUT удаляет старую запись и перезаписывает новую, при этом этот пост доступен по тому же URL

    Нет конкретного правила на использования POST и PUT, но все же стоит придерживаться рекомендаций в целях единообразной трактовки
    методов всеми разработчиками

    Смотрел форум по презентации LARAVEL 9, там говорилось о том, что рекомендуется использовать POST для создания подчиненного ресурса
    (все на том же примере: в блоге много постов, значит посты - подчиненный ресурс)

PATCH используется для частичного изменения ресурса. PUT создает новый ресурс или заменяет представление целевого ресурса, данными представленными в теле запроса.
Другими словами, PATCH вложенный объект содержит набор инструкций, описывающих, как ресурс,
находящийся в данный момент на исходном сервере, должен быть модифицирован для создания новой версии.
А в PUT содержится новая версия ресурса целиком.

Если мы хотим зарегистрировать сразу несколько методов, можем использовать match:
    Route::match(['get', 'post'],  'url', 'function');

Если мы хотим зарегистрировать сразу все методы по руту:
    Route::any('url', 'function')

Любые HTML формы, указывающие на маршруты POST, PUT, PATCH, DELETE - должны быть защищены системой csrf
Для этого в HTML форме достаточно указать '@csrf' сразу после объявления формы

Если мы хотим перенаправить пользователя с одного url на другой - используем redirect:
    Route::redirect('current_url', 'new_url');
По умолчанию возвращается код 302, но его можно переопределить:
    Route::redirect('current_url', 'new_url', 301);
Если нужно вернуть только код состояния, используем permanentRedirect:
    Route::permanentRedirect('current_url', 'new_url');

В дальнейшем слова 'HTML шаблон' я буду заменить на 'вьюха'
Если мы хотим вернуть по определенному url вьюху, то используем view:
    Route::view('url', 'name_of_the_view');
Если нужно передать какие-то параметры во вьюхе, используем:
    Route::view('url', 'name_of_the_view', ['name_of_the_value' => 'value']);

Если нам нужно указывать в url какой-либо параметры типа ID пользователя или номер блога, используем:
    Route::get('url/{value}', function($value) {
        return 'User: ' . $value;
    });

Можно передавать сразу несколько параметров:
    Route::get('url/{some_value}/comments/{some_another_value}', function($some_value, $some_another_value) {
        return 'User: ' . $value . ' Post: ' . $some_another_value;
    });

Если параметр не всегда должен/может присутствовать в маршруте, используем '?':
    Route::get('/url/{value?}' , function($value = null) {
        return $value;
    });
    Route::get('/url/{value?}' , function($value = 'value') {
        return $value;
    });

Можно передать какие-то ограничения по регулярному выражению с помощью '->where()':
    Route::get('/url/{value}', function ($value) {
        // some code
    })->where('value', '[A-Za-z]+');
    Route::get('/url/{value}', function ($value) {
        // some code
    })->where('value', '[0-9]+');
    Route::get('/url/{id}/{value}', function ($value) {
        // some code
    })->where([
        'id' => '[0-9]+'
        'value' => '[0-9]+'
        ]);

Также есть шаблонные правила типа whereNumber, whereAlpha, whereAlphaNumeric:
    Route::get('/url/{id}', function($id) {
        // some code
    })->whereNumber('id');
Если входные значения не пройдут валидацию - будет возвращена 404 ошибка

-----------------------------------------------------------------------------------------------------------
Префиксы для URL
-----------------------------------------------------------------------------------------------------------
Мы можем добавить префикс для группы маршрутов, используем:
Route::prefix('name_of_the_prefix')->group(function() {
    Route::
    Route::
    Route::
});
Тогда мы сможем получить доступ к этим маршрутов по URL:
domain.com/name_of_the_prefix/url

-----------------------------------------------------------------------------------------------------------
Префиксы для ROUTES
-----------------------------------------------------------------------------------------------------------
Мы можем добавить префикс для имен маршрутов, используем:
Route::name('name_of_the_prefix.')->group(function() {
    Route:: -> name('some_name_1');
    Route:: -> name('some_name_2');
    Route:: -> name('some_name_3');
});
Тогда мы сможем получить доступ к этим маршрутам:
    route('name_of_the_prefix.name_of_the_route');

-----------------------------------------------------------------------------------------------------------
Глобальные ограничения
-----------------------------------------------------------------------------------------------------------
Можно поставить определенные ограничения по всем routes в файле RouteServiceProvider в методе boot():
    public function boot()
    {
        Route::pattern('id', '[0-9]+');
    }

-----------------------------------------------------------------------------------------------------------
Именование маршрутов
-----------------------------------------------------------------------------------------------------------
Имена маршрутов всегда должны быть уникальными

Чтобы иметь доступ к маршрутам во views, controller, jobs, commands, events, observers, action-classes, models
(обо всех этих матерных словах позже), можно задать имя маршруту
    Route::get('/url', 'function')->name('name');

Чтобы перенаправить на какой-то route, можем использовать только имя маршрута:
    return redirect()->route('profile');

Можно передать параметры в маршрут, используя имя маршрута:
    Route::get('/url/{id}', function($id) {
        // some logic
    })->name('some_name');

    $url = route('some_name', ['id' => 1]);

Можно передать еще параметры, даже если их нет в самом маршруте, тогда они будут добавлены в url таким образом:
    Route::get('/user/{id}/profile', function ($id) {
        //
    })->name('profile');

    $url = route('profile', ['id' => 1, 'photos' => 'yes']);
    // /user/1/profile?photos=yes

-----------------------------------------------------------------------------------------------------------
Кэширование маршрутов
-----------------------------------------------------------------------------------------------------------
Использования кэша маршрутов гораздо сократит загрузку той или иной страницы.
Чтобы сгенерировать кэш маршрута:
    php artisan route:cache

Но после изменения routes (добавление нового рута, удаление или изменение рута),
кэш нужно обновить. Чтобы перезаписать cache используем всю ту же команду:
    php artisan route:cache

Чтобы очистить кэш маршрутов:
    php artisan route:clear

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                                Controllers
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Контролируем маршруты контроллерами. © Daniil Boyko

Готовьтесь к тому, что вы будете переносить свою логику из callback функций в рутах, в контроллеры,
а потом из controllers в events, из events в observers, из observers в jobs, а потом из jobs в action классы, потому что так - ОПТИМИЗИРОВАННЕЕ! syka...
Обо всех страшных словах потом, пока ты не готов.
На моей личной практике я рефакторил весь проект уже 5 раз, по мере изучения Laravel.

-----------------------------------------------------------------------------------------------------------
Создание контроллера
-----------------------------------------------------------------------------------------------------------
Чтобы создать контроллер, используем:
    php artisan make:controller <NameController>
Хранятся они в каталоге app/Http/Controllers
По рекомендациям разработчиков laravel лучше создавать контроллеры со словом "Controller" в конце названия
UserController, AdminController

-----------------------------------------------------------------------------------------------------------
Базовые понятия
-----------------------------------------------------------------------------------------------------------
В контроллерах мы можем писать методы, которые будут исполняться, когда пользователь будет переходить по какому-то route.
Посмотрите файл RegisterController.php

Чтобы определить метод, который будет исполняться при переходе по руту, в самом объявлении рута пишем:
    Route::get('/url', [ControllerClass::class, 'name_of_the_method'])->name('some_name');

Т.е. когда входящий запрос будет совпадать с указанном URL, будет вызван метод 'name_of_the_method' контроллера 'ControllerClass',
также параметры маршрута будут переданы методу
Пример route с параметрами
    Route::get('/url/{id}', [Controller::class, 'name_of_the_method'])->name('some_name');

Тогда в методе в классе контроллера будем передавать этот 'id'
    public function name_of_the_method($id)
    {
        return $id;
    }

-----------------------------------------------------------------------------------------------------------
Контроллеры одиночного действия
-----------------------------------------------------------------------------------------------------------
Контроллеры одиночного действия - это контроллеры, в которых есть только 1 магический метод - __invoke
Помним из ООП, __invoke - magic method. Он будет исполнен, если не будет найден ни один подходящий метод
Тогда как зарегистрировать этот метод в route? Очень просто, его вообще указывать не нужно
    Route::post('/url', ControllerClass:: class)->name('some_name');

Чтобы сразу сгенерировать контроллер одиночного действия, нужно просто написать:
    php artisan make:controller NameController --invokable

-----------------------------------------------------------------------------------------------------------
Ресурсные контроллеры
-----------------------------------------------------------------------------------------------------------
Ресурсный контроллер - это контроллер, у которого есть все основные методы, отвечающие на GET, PUT, POST.. запросы
Чтобы создать такой контроллер, используем:
    php artisan make:controller NameController --resource

Можно зарегистрировать ресурсный route, используя:
    Route::resource('/url', NameController::class);

Пока не напишешь говно-код, не поймешь что такое говно-код. © Daniil Boyko
К чему я это? А к тому, что можно и объявлять несколько ресурсных контроллеров сразу
    Route::resources([
        '/photos' => PhotoController::class,
        '/posts' => PostController::class,
    ]);
Но это bad pattern, никогда так не делайте, иначе при удалении какого-либо из методов в одном из этих контроллеров,
придется вытягивать это из массива, переписывать руты

Действия, выполняемые ресурсными контроллерами
Метод	        URI	               Действие	        Имя маршрута
GET	        /photos	                index	        photos.index
GET	        /photos/create	        create	        photos.create
POST	    /photos	                store	        photos.store
GET	        /photos/{photo}	        show	        photos.show
GET	        /photos/{photo}/edit	edit	        photos.edit
PUT/PATCH	/photos/{photo}	        update	        photos.update
DELETE	    /photos/{photo}	        destroy	        photos.destroy

Никто не ограничивает вас в том, чтобы добавить новые методы в ресурсный или какой-либо другой контроллер
Точно также
1) Добавляем метод в контроллер, пишем логику в методе
2) Добавляем его в рутах и все

Там дальше идет взаимодействие с service container и eloquent моделями, но пока, как я понимаю,
это темный лес, поэтому пока закончу на этом свой рассказ

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                                Middlewares
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Волк не тот, кто работает с данными. Волк тот, кто работает с данными. © Daniil Boyko

Переходим к страшному слову middleware

-----------------------------------------------------------------------------------------------------------
Базовые понятия
-----------------------------------------------------------------------------------------------------------
По-быстрому что это и зачем нужно:
Мы хотим перейти на какой-то рут, чтобы увидеть вьюху или отправить какие-то данные в форме (например, зарегистрироваться)
Наверняка слышали о MVC - Model View Controller

Для себя я объяснил это так:
    У нас есть три этапа жизни запроса
    1) Отправка самого запроса
    2) Валидация данных
    3) Получение результата в контроллере
Вот то, что делает middleware - находится между 1 и 2 пунктом. По-русски middleware - посредник.
Сейчас легкое объяснение, по которому поймете. Например, middleware 'auth'
Он проверяет авторизирован ли пользователь в нашем приложении, если ответ положительный - он перенаправляет запрос в контроллер.
Надеюсь понятно, что это чистый приспособленец валидации

-----------------------------------------------------------------------------------------------------------
Создание middleware
-----------------------------------------------------------------------------------------------------------
Чтобы создать middleware, используем:
php artisan make:middleware NameMiddleware
Опять же, в конце названия middleware (посредника) - надо писать слово Middleware, чтобы в первую очередь вам было легче потом искать конкретный файл
Но просто создать middleware и написать там логику - мало, надо его еще зарегистрировать.
Где регистрировать?
    Ответ: в app/Http/Kernel.php

Коротко о том, что находится в этом файле:
В свойстве $routeMiddleware содержатся уже зарегистрированные Laravel middlewares, которые идут из коробки.
Можем добавить туда свой middleware:
    'alias' => NameMiddleware::class,

-----------------------------------------------------------------------------------------------------------
Использование middleware
-----------------------------------------------------------------------------------------------------------
Написали логику в посреднике, зарегистрировали его, а как применять? Вот так:
    Route::get('/url', function() {
        // some code
    }->middleware('alias');

Если вам одного посредника мало, вы абьюзер и хотите еще больше ограничить права людей, то вот как применять сразу несколько посредников на один маршрут:
    Route::get('/url', function() {
        // some code
    }->middleware(['alias_1', 'alias_2']);

Но можно и не указывать алиасы, а просто передать instance:
    Route::get('/url', function() {
         // some code
    }->middleware(NameMiddleware::class);

Помните в разделе про руты, можно было группировать маршруты, так вот можно и применять middleware сразу на всю группу маршрутов:
    Route::prefix('name_of_the_prefix')->group(function() {
        Route::middleware([NameMiddleware::class])->group(function() {
            Route:: ;
            Route:: ;
            Route:: ;
        });
    });

Не хотите так? Можно и так:
    Route::prefix('name_of_the_prefix')->group(function() {
        Route::group(['middleware' => NameMiddleware::class], function() {
            Route:: ;
            Route:: ;
            Route:: ;
        });
    });

Может быть такая ситуация, когда какой-то маршрут из группы не вынесешь, потому что будет не очень красиво,
тогда можно исключить middleware для этого рута:
    Route::prefix('name_of_the_prefix')->group(function() {
        Route::group(['middleware' => NameMiddleware::class], function() {
            Route:: ;
            Route:: ;
            Route::get('/url', function() {
                // some code here
            })->withoutMiddleware([NameMiddleware::class]);
        });
    });

-----------------------------------------------------------------------------------------------------------
Группы of middlewares
-----------------------------------------------------------------------------------------------------------
Пойдем дальше по файлу Kernel.php - его кстати называют HTTP ядром приложения
    Свойство $middlewareGroups. Зачем нужно? У нас ведь есть alias для какого-то конкретного посредника (в свойстве $routeMiddleware),
    так вот можно назначить несколько посредников сразу под один alias. Надеюсь, догадаетесь как добавлять -_-

    Ну тогда и применять эти middlewares будем по одному alias:
        Route::get('/url', function () {
            // some code here
        })->middleware('alias');
    Ну или так, никакой разницы:
        Route::middleware(['alias'])->group(function() {
            Route::get('/url', function () {
                // some code here
            }
        }

-----------------------------------------------------------------------------------------------------------
Приоритетность посредников
-----------------------------------------------------------------------------------------------------------
Далее есть предопределенное свойство $middlewarePriority. Зайди и посмотри, что там перечислено.

Гы. Его там нет, иди сюда обратно. Ну и куда ты пошел смотреть его?
Это свойство нужно объявить, если тебе важен порядок выполнения middleware. На моей практике не требовалось этого.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                                Views
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Только дед инсайды возвращают в callback функциях HTML-код. © Daniil Boyko

-----------------------------------------------------------------------------------------------------------
Базовые понятия
-----------------------------------------------------------------------------------------------------------
Все шаблонные представления (далее вьюхи) располагаются в каталоге resources/views/
Чтобы вьюха была доступна по руту, для начала как бы ее надо создать.
Про то, почему шаблонизатор '.blade.php' лучше простого HTML - потом.
После создания, вьюху можно получить так:
    Route::get('/url', function() {
        return view('name_of_the_view');
    });

Либо можно использовать фасад View:
    Route::get('/url', function() {
        return View::make('name_of_the_view');
    });

Чтобы передать какой-то параметр во вьюху, используем:
    Route::get('/url/', function() {
        return view('name_of_the_view', ['name' => 'Danya']);
    });
    И в самой вьюхе тогда:
    <html>
        <body>
            <h1>Привет, {{ $name }}</h1>
        </body>
    </html>

-----------------------------------------------------------------------------------------------------------
Получение вьюхи из поддиректорий
-----------------------------------------------------------------------------------------------------------
Рассмотрим кейс, если у нас есть поддиректория в каталоге views. Например /resources/views/admin/index.blade.php
Тогда возврат вьюхи будет выглядеть так:
    Route::get('/url', function() {
        return view('admin.index');
    });

Честно, следующий кейс не знаю когда может применяться, но запихну его сюда.
    Route::get('/url', function() {
        if (View::exists('name_of_the_view')) {
            return view('name_of_the_view');
        } else {
            abort(403);
        }
    });
Это типо если вы не знаете есть вьюха или нет, но понятия не имею как разработчик может не знать какие вьюхи есть в проекте, а какие нет.
В sxope-ocean нет ни одного такого примера.

Есть еще способ как передать данные во вьюху:
    Route::get('/url', function() {
        return view('admin.index')
            ->with('name', 'Danya')
            ->with('surname', 'Boyko');
    });

-----------------------------------------------------------------------------------------------------------
Передача данных из контроллера во вьюху
-----------------------------------------------------------------------------------------------------------
1) Объявили рут:
    Route::get('/test-data-to-view', [UserController::class, 'testDataToView'])->name('test-data-to-view');

2) Написали метод в контроллере. Вот, то как правильнее передавать данные во вьюху. Не знаю почему, но ->with у меня не всегда работает. С чем связано - не знаю.
    public function testDataToView()
    {
        $id = 123123123;
        return view('views-tester', compact('id'));
    }
3) Вывели это в /resources/views/views-tester.blade.php
    {{ $id }}

-----------------------------------------------------------------------------------------------------------
Шаринг данных на все вьюхи
-----------------------------------------------------------------------------------------------------------
Бывают такие кейсы, когда данные должны передаваться во все вьюхи сразу, а если таких вьюх тысяча, то что делать?
Правильно, зарегистрировать эти переменные и значения в AppServiceProvider.php в методе 'boot'. Ага, так ты и ответил, конечно.
    public function boot()
    {
        View::share('key', 'value');
    }

-----------------------------------------------------------------------------------------------------------
Кэширование вьюх
-----------------------------------------------------------------------------------------------------------
Честно, это заеб. Ничего больше не могу сказать. Кэшировать то легко, но точно как в случае с рутами:
При каждом изменении во вьюхе, нужно будет переопределять кэш, чтобы увидеть окончательный результат.
Считаю, что кэширование нужно на каких-то крупных сервисах, потому что это оптимизация, на localhost это ни к чему.
Но все же, чтобы закэшировать вьюхи, используем:
    php artisan view:cache

Очистить кэш вьюх:
    php artisan view:clear

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                                Models
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Laravel модель это не Kylie Jenner, но поебаться с этим стоит. © Daniil Boyko

-----------------------------------------------------------------------------------------------------------
Базовые понятия
-----------------------------------------------------------------------------------------------------------
Laravel содержит ORM-библиотеку Eloquent. Все дружно поняли, что такое ORM-библиотеку, ага, конечно.
ORM - Object Relational Mapping, это библиотека, которая позволяет взаимодействовать с базой данных в рамках концептах ООП.
Также это может означать Object Role Model. При использовании Eloquent каждая таблица БД имеет Модель, которая используется
для взаимодействия с таблицей.
Создайте базу mysql, вот мои конфиг в .env:
    DB_CONNECTION=mysql
    DB_HOST=127.0.0.1
    DB_PORT=3306
    DB_DATABASE=laravel
    DB_USERNAME=root
    DB_PASSWORD=

-----------------------------------------------------------------------------------------------------------
Создание моделей
-----------------------------------------------------------------------------------------------------------
Чтобы создать модель, используем:
    php artisan make:model Post
Чтобы создать модель сразу с миграцией:
    php artisan make:model Post --migration
    php artisan make:model Post -m
Можно комбинировать флаги, например:
    php artisan make:model Post -mfsc - Это создает модель, миграцию, фабрику, сид, контроллер
О том, что такое фабрика и сид - позже.
Созданные модели находятся в app\Models.

-----------------------------------------------------------------------------------------------------------
Соглашение по именованию моделей
-----------------------------------------------------------------------------------------------------------
По умолчанию при создании модели Post, Laravel подразумевает, что эта модель будет связана с таблицей posts в базе данных
Тоже самое: модель User - табличка users

-----------------------------------------------------------------------------------------------------------
Конфигурация моделей
-----------------------------------------------------------------------------------------------------------
Бывают такие кейсы, в которых нужно другое название таблицы, например:
    Модель Post - таблица history_posts;
Тогда в классе модели можно просто указать protected свойство $table = 'history_posts';

Предполагается из коробки, что первичным ключом в каждой таблицы будет 'id', но если он у нас другой, то в классе модели:
    protected $primaryKey = 'another_name_of_primary_key';

Laravel также предполагает, что primary key является auto-incrementing (т.е. увеличивающимся автоматически на 1) integer.
Но если, например, у нас есть табличка currencies (валюты), то удобнее держать primary key в виде названия валюты, т.е string.
Тогда в модели указываем:
    public $incrementing = false;
    protected $keyType = 'string';

Составные первичные ключи не поддерживаются Eloquent, но можно создать дополнительные уникальные индексы к таблицам БД

В каждой табличке Laravel автоматически определит две колонки: created_at, updated_at. Если не хотим их видеть:
    public $timestamps = false;

Если мы хотим поменять формат даты в колонках:
    protected $dateFormat = 'U';

Если мы хотим изменить начальные имена created_at, updated_at колонок, то в классе модели:
    CONST CREATED_AT = 'creation_date';
    CONST UPDATED_AT = 'updated_date';

Если хотим указать не дефолтное значение в подключении к БД, то:
    protected $connection = 'another_connection';

Если хотим указать стандартное значение для определенных полей, то:
    protected $attributes = [
        'name' => 'Danya';
    ];


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                        Eloquent query builder
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Чтобы получить все записи таблички, связанной с моделью:
    $users = User::all();
    foreach($users as $user) {
        echo $user->name;
    }

Также можно получать записи с дополнительными условиями:
    $users = User::where('name', '=', 'John')
        ->orderBy('id')
        ->take(10)
        ->get();
Здесь
   WHERE - аналог WHERE в sql
   TAKE - аналог LIMIT
   GET - получение результатов

Метод refresh повторно обновит модель, используя свежие данные из БД:
    $flight = Flight::where('number', 'FR 900')->first();
    $flight->number = 'FR 456';
    $flight->refresh();
    $flight->number; // "FR 900"

Методы all и get возвращают не массив, а экземпляр класса Collection, который содержит много полезных методов.

Отображение записей, используя chunks, меньшее потребление памяти при работе с большим количеством моделей
    User::chunk(200, function($users) {
    foreach($users as $user)
        echo $user->name;
    });

Обновление, используя chunks, сортировка по Id
    User::where('is_active', '=', true)
        ->chunkById(200, function ($users)) {
            $users->each->update(['is_admin' => true]);
        }, $column = 'id')

Метод lazy работает концептуально как chunks, только с lazy вы работаете с единым потом, а chunks берет каждую модель отдельно
lazy возвращает экземпляр класса LazyCollection одноуровневых моделей Eloquent
    foreach(User::lazy() as $user) {
        // some code here
    }

Обновление, используя lazy, сортировка по Id
    User::where('is_active', '=', true)
        ->lazyById(200, function ($users)) {
            $users->each->update(['is_admin' => true]);
        }, $column = 'id')

Либо можно отфильтровать результаты по убыванию Id:
    User::where('is_active', '=', true)
        ->lazyByIdDesc(200, function ($users)) {
            $users->each->update(['is_admin' => true]);
        }, $column = 'id')

Отображение результатов с помощью курсора:
    $users = User::cursor()->filter(function ($user) {
        return $user->id > 500;
    });

    foreach ($users as $user) {
        echo $user->id;
    }

-----------------------------------------------------------------------------------------------------------
                                            Расширенные подзапросы
-----------------------------------------------------------------------------------------------------------
Eloquent также предлагает поддержку расширенных подзапросов, которая позволяет извлекать информацию из связанных таблиц в одном запросе.
Долго не мог понять как вывести это в обычный SQL-запрос, а потом просто нашел метод ->toSql()...
    Destination::addSelect(['last_flight' => Flight::select('name')
        ->whereColumn('destination_id', 'destinations.id')
        ->orderByDesc('arrived_at')
        ->limit(1)

    select `users`.*,
           (
            select
                `is_published`
            from
                `posts`
            ) as `is_published`
    from `users`
    where `posts`.`user_id` = `users`.`id`
      and `users`.`deleted_at` is null
    order by `email` desc
    limit 1

Кроме того, метод orderBy построителя запросов поддерживает подзапросы:
    User::orderByDesc(
                    Post::select('is_published')
                        ->whereColumn('user_id', 'users.id')
                        ->orderByDesc('is_published')
                        ->limit(1))
    select
        *
    from
        `users`
    where
        `users`.`deleted_at` is null
    order by
        (
            select
                `is_published`
            from
                `posts`
            where
                `user_id` = `users`.`id`
            order by
                `is_published` desc
            limit 1
        ) desc

Хотя метод cursor использует гораздо меньше памяти, чем обычный запрос (удерживая в памяти только одну модель Eloquent),
он все равно в конечном итоге может исчерпать память.
Если нужно работать с большим количеством записей - то используете lazy.

get() ->
    Работает быстро, но жрет много памяти, под капотом использует fetchAll, загружаю сразу все.
cursor() ->
    Работает медленно, но жрет мало памяти, под капотом использует fetch. Итерации выполняются одна за другой;
    Не загружает отношения;
    Не может работать с большими коллекциями, закончится память;
    Так как загрузка данных происходит только по одной записи за раз, это позволит сохранить согласованность при обработке наборов данных,
    которые могут измениться в процессе работы;
    Модели не будут включены, пока не будут фактически итерированы.
chunk() ->
    Меньше вызовов fetchAll, пытается разбить большой результат на маленькие, используя предел указанный тобой;
    В каком-то смысле chunk использует преимущества get() и cursor();
    Наименьшее использование памяти;
    Самый медленный способ;
    Если одновременно выполняем итерацию и обновляем данные, используй chunkById;
    Могут возникнуть проблемы при обновлении первичных и внешних ключей.
lazy() ->
   По сути, она делает то же самое, что и chunk(). Однако вам не нужен обратный вызов,
   поскольку он использует PHP-генераторы и возвращает LazyCollection, что делает синтаксис более чистым;
   Низкое использование памяти;
   Более приятный синтаксис, чем chunk();
   Если вы одновременно выполняете итерацию и обновление записей, используйте lazyById.

-----------------------------------------------------------------------------------------------------------
                                        Извлечение отдельных моделей
-----------------------------------------------------------------------------------------------------------
Получить модель по первичному ключу:
$user = User::find(1);

Получить первую модель, соответствующую условиям запроса:
$user = User::where('is_active', true)->first();

Тот же запрос, но другим способом:
$user = User::firstWhere('is_active', true);

Найти первый результат, а если не найден - то сделать определенные действия
$model = User::where('name', '=', 'Daniil Boyko')->firstOr(function() {
    echo 'Ok, ok, here we go again...';
});

Выбросить исключение при отсутствии результатов запроса:
$user = User::findOrFail(1);
$user = User::where('name', '=', 'Daniil Boyko')->firstOrFail();

Если исключение не перехвачено, то клиенту автоматически отправляется HTTP-ответ 404:
Route::get('/api/flights/{id}', function ($id) {
    return Flight::findOrFail($id);
});

Получить рейс по `name` или создать его, если его не существует:
$flight = Flight::firstOrCreate([
    'name' => 'London to Paris'
]);

Получить рейс по `name` или создать его с атрибутами `name`,` delayed` и `arrival_time`:
$flight = Flight::firstOrCreate(
    ['name' => 'London to Paris'],
    ['delayed' => 1, 'arrival_time' => '11:30']
);

Получить рейс по `name` или создать новый экземпляр Flight:
$flight = Flight::firstOrNew([
    'name' => 'London to Paris'
]);

Получить рейс по `name` или создать экземпляр с атрибутами `name`, `delayed` и `arrival_time`:
$flight = Flight::firstOrNew(
    ['name' => 'Tokyo to Sydney'],
    ['delayed' => 1, 'arrival_time' => '11:30']
);

-----------------------------------------------------------------------------------------------------------
Извлечение агрегатов
-----------------------------------------------------------------------------------------------------------
Количество записей по условию:
$count = Flight::where('active', 1)->count();

Максимальное значение по условию:
$max = Flight::where('active', 1)->max('price');

Другие агрегатные функции:
https://laravel.su/docs/8.x/queries#aggregates

-----------------------------------------------------------------------------------------------------------
Создание моделей
-----------------------------------------------------------------------------------------------------------
Мы возвращаемся к контроллерам, потому что писать в рутах в callback функции какую-то логику - это кринж.
class UserController
{
    public function store()
    {
        $user = new User();
            Можно так
        $user->name = $request->name;
            А можно так
        $user->name = $request->input('name');

        $user->save();
        Когда мы сейвим эту запись, поля created_at и update_at будут заполнены автоматически
    }
}

Также создавать модели можно и другим способом:
$user = User::create([
    'name' => 'Daniil Boyko',
]);
Но тогда перед использованием метода create нужно указать в классе модели такие свойства как fillable и guarded.
 * Поля которые могут быть заполнены вручную.
    protected $fillable = [
        'name',
        'email',
        'password',
    ];

 * Поля которые защищены от ручной вставки.
    protected $hidden = [
        'password',
        'remember_token',
    ];

Мы также можем добавить 2 условия в where, когда ищем записи:
$user = User::where('is_active', true)
    ->where('name', '=', 'Daniil Boyko')
    ->update(['is_admin' => true]);
Метод update ожидает массив пар ключей и значений, представляющих столбцы, которые должны быть обновлены.

-----------------------------------------------------------------------------------------------------------
Грязные/чистые модели
-----------------------------------------------------------------------------------------------------------
Метод isDirty определяет была ли изменена модель в текущем состоянии.
isClean делает точно наоборот.
Оба этих методов можно применять не ко всей модели в целом, а только к полю.
    $user = User::create([
        'first_name' => 'Taylor',
        'last_name' => 'Otwell',
        'title' => 'Developer',
    ]);

    $user->title = 'Painter';

    $user->isDirty(); // true
    $user->isDirty('title'); // true
    $user->isDirty('first_name'); // false

    $user->isClean(); // false
    $user->isClean('title'); // false
    $user->isClean('first_name'); // true

    $user->save();

    $user->isDirty(); // false
    $user->isClean(); // true

По названию метода wasChanged наверно понятно, какой результат она выдаст и при каком условии.
Вот пример кода:
    $user = User::create([
        'first_name' => 'Taylor',
        'last_name' => 'Otwell',
        'title' => 'Developer',
    ]);

    $user->title = 'Painter';

    $user->save();

    $user->wasChanged(); // true
    $user->wasChanged('title'); // true
    $user->wasChanged('first_name'); // false

По названию метода getOriginal должно быть понятно, что происходит:
Вот пример кода:
    $user = User::find(1);

    $user->name; // Daniil
    $user->email; // email@example.com

    $user->name = "Jack";
    $user->name; // Jack

    $user->getOriginal('name'); // Daniil
    $user->getOriginal(); // Массив исходных атрибутов ...

Метод обновления-вставки:
В приведенном ниже примере, если существует рейс с пунктом отправления «Oakland» и пунктом назначения «San-Diego»,
его столбцы price и discounted будут обновлены. Если такой рейс не существует, то будет создан новый рейс с атрибутами,
полученными в результате слияния первого массива аргументов со вторым массивом аргументов.
    $flight = Flight::updateOrCreate(
        ['departure' => 'Oakland', 'destination' => 'San Diego'],
        ['price' => 99, 'discounted' => 1]
    );

Тут уже пошло совсем извращенство:
Если вы хотите выполнить несколько «обновлений-вставок» в одном запросе, вам следует использовать вместо этого метод upsert.
Первый аргумент метода состоит из значений для вставки или обновления, а второй аргумент перечисляет столбцы,
которые однозначно идентифицируют записи в связанной таблице.
Третий и последний аргументы метода – это массив столбцов, которые следует обновить, если соответствующая запись уже существует в БД.
Метод upsert автоматически устанавливает временные метки created_at и updated_at, если они разрешены в модели:
    Flight::upsert([
        ['departure' => 'Oakland', 'destination' => 'San Diego', 'price' => 99],
        ['departure' => 'Chicago', 'destination' => 'New York', 'price' => 150]
    ], ['departure', 'destination'], ['price']);

-----------------------------------------------------------------------------------------------------------
Удаление моделей
-----------------------------------------------------------------------------------------------------------
Удаление модели, тут нехуй добавить, нехуй убавить
    $user = User::find(1);
    $user->delete();

Можно удалить все модели
    User::truncate();

Удаление модели по ID:
    Flight::destroy(1);
    Flight::destroy(1, 2, 3);
    Flight::destroy([1, 2, 3]);
    Flight::destroy(collect([1, 2, 3]));

Удаление по условию:
    $deletedRows = Flight::where('active', 0)->delete();

Теперь о том, что такое softDelete;
Надо написать миграцию в табличку со строкой
    Schema::table('flights', function (Blueprint $table) {
        $table->softDeletes();
    });
    и в классе модели написать use SoftDeletes;

Это добавляет колонку deleted_at.
Теперь если вы будете удалять какую-то строку из таблички, по сути она удаляться не будет, но в поле deleted_at появится timestamp удаления.
Соответственно если мы в дальнейшем будем писать select на табличку - эти записи не будут показываться в результате запроса.
Чтобы восстановить какую-то softDelete запись, то указываем:
    $user->restore()
Либо
    App\Models\Flight::withTrashed()
        ->where('airline_id', 1)
        ->restore();

Чтобы полностью удалить запись из таблички, которая имеет softDelete, указываем:
    $user->forceDelete();

Метод onlyTrashed покажет только программно удаленные записи:
    $flights = Flight::onlyTrashed()
        ->where('airline_id', 1)
        ->get();


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                            Service Container
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Даже не думай сразу про контейнер для еды, иди лучше похудей. Тут серьезные ребята, мы говорим о контейнере служб. © Daniil Boyko

-----------------------------------------------------------------------------------------------------------
Базовые понятия
-----------------------------------------------------------------------------------------------------------
Контейнер служб - мощный инструмент управления зависимостями классов и выполнения внедрения зависимостей.
Если коротко и без воды - когда мы передаем в какой-то метод переменную класса, то под капотом автоматически создается
экземпляр класса.
Просто пример:
    class UserController extends Controller
    {
        protected $users;

        public function __construct(UserRepository $users)
        {
            $this->users = $users;
        }

        /**
        *   Показать профиль конкретного пользователя
        */
        public function show($id)
        {
            $user = $this->users->find($id);
            return view('user.profile', ['user' => $user];
        }
    }

Если класс не имеет зависимостей или зависит только от других конкретных классов (не интерфейсов),
контейнер не нужно инструктировать о том, как создавать этот класс.
Допустим есть какой-то класс Service:
    class Service
    {
        //
    }

Тогда, например, в routes/web.php:
    Route::get('/', function(Service $service) {
        die(get_class($service));
    });

В этом примере при посещении '/' рута, маршрут автоматически получит экземпляр класса Service
и внедрит его в обработчике вашего маршрута.
Многие классы, которые мы используем в процессе разработки приложения Laravel получают свои зависимости через контейнер,
включая controllers, listeners, events, middlewares и так далее. Так можно указать зависимости в методе handle в job.
О том, что такое listeners, events, jobs чуть позже. Как только потренируетесь с автоматическим
неконфигурируемым внедрением зависимостей, ты почувствуешь невозможность разработки без нее.

-----------------------------------------------------------------------------------------------------------
Service Provider
-----------------------------------------------------------------------------------------------------------
Это центральное место начальной загрузки всех приложений Laravel.
Что подразумевается под начальной загрузкой? Это регистрация элементов, включая регистрацию связываний контейнера служб,
слушателей (listeners), событий (events), посредников (middleware), маршрутов (routes).
Сервис-провайдеры - центральное место для конфигурирования приложения.

В файле config/app.php, мы увидим массив $providers. Это все классы сервис-провайдеров, которые будут загружены вашим приложением.
Они загружают основные компоненты Laravel, такие как подсистема отправки почты, очередь, кэш и другие.
Многие из них являются "отложенными", это значит что они не будут загружаться при каждом запросе, а только так,
когда предоставляемые ими службы действительно необходимы.
По умолчанию там основные сервис-провайдеры, но никто не запрещал добавлять свои.

Структура service provider.
Почти в каждом сервис-провайдере есть всего два методы: register и boot.
В рамках метода register следует только связывать (биндить) сущности в контейнере служб.
Никогда не следует пытаться зарегистрировать каких-либо слушателей событий, маршруты или что-то другое в методе register.
В противном случае вы можете случайно воспользоваться подсистемой, чей сервис-провайдер еще не загружен.

Как сгенерировать новый сервис-провайдер?
    php artisan make:provider RiskServiceProvider

Напишем что-то в методе register, и я не говорю про фразу "акуленок ту руруру".
В любом из методов сервис-провайдера у вас есть доступ к свойству $app, которое обеспечивает доступ к контейнеру служб:

    class RiskServiceProvider extends ServiceProvider
    {
        /**
         * Регистрация любых служб приложения.
         *
         * @return void
         */
        public function register()
        {
            $this->app->singleton(Connection::class, function ($app) {
                return new Connection(config('riak'));
            });
        }
    }

    Если ваш сервис-провайдер регистрирует много простых связываний,
    вы можете использовать свойства bindings и singletons вместо ручной регистрации каждого связывания контейнера.
    Когда сервис-провайдер загружается фреймворком, он автоматически проверяет эти свойства и регистрирует их связывания:
    class AppServiceProvider extends ServiceProvider
    {
        /**
         * Все связывания контейнера, которые должны быть зарегистрированы.
         *
         * @var array
         */
        public $bindings = [
            ServerProvider::class => DigitalOceanServerProvider::class,
        ];

        /**
         * Все singleton контейнера, которые должны быть зарегистрированы.
         *
         * @var array
         */
        public $singletons = [
            DowntimeNotifier::class => PingdomDowntimeNotifier::class,
            ServerProvider::class => ServerToolsProvider::class,
        ];
    }

Теперь поговорим про метод boot.
Это метод вызывается после регистрации всех остальных сервис-провайдеров, что означает,
что в этом месте у вас уже есть доступ ко всем другим службам, которые были зарегистрированы фреймворком.
    class ComposerServiceProvider extends ServiceProvider
    {
        /**
         * Загрузка любых служб приложения.
         *
         * @return void
         */
        public function boot()
        {
            View::composer('view', function () {
                //
            });
        }
    }
-----------------------------------------------------------------------------------------------------------
Когда использовать контейнер?
-----------------------------------------------------------------------------------------------------------
При валидации, например, данных из формы - мы передаем в метод контроллера параметр Request $request.
Это уже внедрение зависимости. Но в данном случае мы не трогаем контейнер.
    Во-первых, если вы пишете класс, реализующий интерфейс,
        и хотите объявить тип этого интерфейса в конструкторе маршрута или класса, то вы должны сообщить контейнеру,
        как получить этот интерфейс.
    Во-вторых, если вы пишете пакет Laravel,
        которым планируете поделиться с другими разработчиками Laravel,
        вам может потребоваться связать службы вашего пакета в контейнере.

-----------------------------------------------------------------------------------------------------------
Отложенные провайдеры
-----------------------------------------------------------------------------------------------------------
Если ваш сервис-провайдер регистрирует только связывания в контейнере служб, вы можете отложить его регистрацию до тех пор,
пока одно из зарегистрированных связываний не понадобится. Отсрочка загрузки повысит производительность приложения,
так как он не загружается из файловой системы при каждом запросе.
Laravel загрузит отложенный сервис-провайдер только при необходимости одной из этих служб.

Чтобы отложить загрузку сервис-провайдера, надо реализовать интерфейс DefferableProvider, описав метод provides.
Метод provides должен вернуть связывания контейнера службы, регистрируемые данным классом:
    class RiakServiceProvider extends ServiceProvider implements DeferrableProvider
    {
        /**
         * Регистрация любых служб приложения.
         *
         * @return void
         */
        public function register()
        {
            $this->app->singleton(Connection::class, function ($app) {
                return new Connection($app['config']['riak']);
            });
        }

        /**
         * Получить службы, предоставляемые поставщиком.
         *
         * @return array
         */
        public function provides()
        {
            return [Connection::class];
        }
    }

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                            Jobs, Queues
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-----------------------------------------------------------------------------------------------------------
Базовые понятия
-----------------------------------------------------------------------------------------------------------
При разработке приложения, у вас могут быть трудоемкие задания, такие как сохранение большого CSV файла, анализ данных и так далее
В случае sxope-ocean - километровые SQL-запросы в огромную базу данных.
С помощью Laravel можно легко создавать задания (jobs) в очереди (queue), которые могут работать в фоновом режиме.
Благодаря этому, ваше приложения может быстрее обрабатывать веб-запросы и быстрее отвечать клиенту.

Параметры конфигурации находятся в файле - config/queue.php. Там можно найти параметры подключения каждых из драйверов очереди фреймворка:
    Redis,
    Amazon SQS,
    Database и другие.
Также имеется драйвер очереди null, который просто выбрасывает задания из очереди, не исполняя их.

!!! Сейчас очень важно понять различие между очередями и соединениями.
    1) В конфиге queue.php есть массив connections.
    2) Этот массив определяет подключение к серверным службам очередей: Amazon SQS, Beanstalk, Redis, etc.
    3) ЛЮБОЕ УКАЗАННОЕ СОЕДИНЕНИЕ МОЖЕТ ИМЕТЬ НЕСКОЛЬКО ОЧЕРЕДЕЙ, который можно рассматривать как разные стеки или пачки поочередных заданий.

-----------------------------------------------------------------------------------------------------------
Очереди
-----------------------------------------------------------------------------------------------------------
Каждый пример соединения содержит себе ключ 'queue' - это название очереди по умолчанию.
Другими словами, если вы отправляете задание без явного определения очереди, в которую оно должно быть отправлено,
задание будет поставлено в очередь, определённую в ключе queue конфигурации соединения.

    UserFiller::dispatch() -> пойдет в очередь default.
    UserFiller::dispatch()->onQueue('emails') -> пойдет в очередь emails.

-----------------------------------------------------------------------------------------------------------
Приоритетность очередей
-----------------------------------------------------------------------------------------------------------
Отправка заданий в несколько очередей может быть полезна для приложений, определяющие приоритеты или сегментацию процесса обработки заданий.
Если помещать задания в очередь, которая должна соответствовать более высокому приоритету, то можем явно указать приоритет очередей.
    php artisan queue:work --queue=name_with_higher_priority, name_with_lower_priority

-----------------------------------------------------------------------------------------------------------
Использование очередей с драйвером database
-----------------------------------------------------------------------------------------------------------
Для начала нам понадобится табличка jobs, чтобы ее создать:
    1) php artisan queue:table
    2) php artisan migrate
    3) В файле .env указываем QUEUE_CONNECTION=database
С остальными драйверами пока не работал, поэтому не буду писать то, чего не знаю.

Поговорим о том, что произойдет при выполнении трех действий, описанных выше.
В первом этапе создастся две таблички: jobs, failed_jobs

Тут прочитайте ОЧЕНЬ ВНИМАТЕЛЬНО, потому что я долго не понимал почему не работает.
    1) В табличке jobs, лежат задания которые ОЖИДАЮТ ВЫПОЛНЕНИЯ. То есть это НЕ ИСТОРИЯ ДЖОБОВ, а просто задания, который в данный момент
        ЛЕЖАТ В ОЧЕРЕДИ И НЕ ВЫПОЛНЯЮТСЯ, потому что очередь занята выполнением другого задания.
    2) После выполнения всех заданий из всех очередей, табличка jobs будет пуста.
    3) В табличке failed_jobs содержатся ошибки, которые были вызваны при выполнении jobs.

-----------------------------------------------------------------------------------------------------------
Создание и структура заданий (jobs)
-----------------------------------------------------------------------------------------------------------
Чтобы создать job, используем:
    php artisan make:job UserFiller

Сгенерированный класс будет реализовывать интерфейс ShouldQueue, что означает: задание должно быть поставлено в очередь
для асинхронного выполнения.

Классы задания очень простые, обычно они содержат только метод handle(), который вызывается, когда задание обрабатывается очередью.
В sxope-ocean это итоговый метод getQuery.
