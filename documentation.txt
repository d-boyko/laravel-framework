# Laravel Framework Documentation
was made according to self-improvement spreadsheet

Рекомендую курсы:
Max Orlov - Laravel
Cutcode - Laravel

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                                  Routes
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Пример route с callback функцией:
    Route::get('/hello', function() {
        return 'Hello World';
    });
Следовательно, после перехода в браузере на url: 127.0.0.1:8000/hello - мы увидим надпись Hello World

По умолчанию все routes находятся в файле routes/web.php
Мы можем зарегистрировать новый файл в RouteServiceProvider.php
    Route::middleware('web')
        ->group(function() {
            require base_path('routes/web.php');
            require base_path('routes/admin.php');
            require base_path('routes/user.php');
        });
О страшном слове middleware позже

-----------------------------------------------------------------------------------------------------------
Routes types:
    Route::get('url', 'function');
    Route::post('url', 'function');
    Route::put('url', 'function');
    Route::patch('url', 'function');
    Route::delete('url', 'function');
    Route::options('url', 'function');
-----------------------------------------------------------------------------------------------------------
GET метод позволяет получить все то, что нельзя никак отредактировать, добавить, удалить и так далее (к примеру HTML странички)
POST - может использоваться также для редактирования ресурса
PUT - для редактирования ресурса
DELETE - удаление ресурса
OPTIONS - представляет запрос информации об опциях соединения, доступных в цепочке запросов/ответов (короче конфиг)

Вроде с помощью POST можно редактировать какую-то запись и с помощью PUT, так в чем же разница?
    Представь, что у нас есть сервис с блогом и постами. В одном блоге может быть несколько постов.
    Для добавления нового поста мы конечно используем метод POST с url например: domain.com/blogs/id
    После создания нового поста метод POST сам создаст URL и вернет этот URL для доступа к нему через GET или для удаления через DELETE

    А теперь допустим, что такой пост уже создан и клиент хочет просто отредактировать его (исправить синтаксическую ошибку например)
    То есть другими словами, клиент хочет ПЕРЕЗАПИСАТЬ пост
    Для этого будет использован метод PUT с URL: domain.com/blogs/id/posts/post_id, он передает обновленную запись в теле запроса
    Сервис, ориентируясь на метод PUT удаляет старую запись и перезаписывает новую, при этом этот пост доступен по тому же URL

    Нет конкретного правила на использования POST и PUT, но все же стоит придерживаться рекомендаций в целях единообразной трактовки
    методов всеми разработчиками

    Смотрел форум по презентации LARAVEL 9, там говорилось о том, что рекомендуется использовать POST для создания подчиненного ресурса
    (все на том же примере: в блоге много постов, значит посты - подчиненный ресурс)

PATCH используется для частичного изменения ресурса. PUT создает новый ресурс или заменяет представление целевого ресурса, данными представленными в теле запроса.
Другими словами, PATCH вложенный объект содержит набор инструкций, описывающих, как ресурс,
находящийся в данный момент на исходном сервере, должен быть модифицирован для создания новой версии.
А в PUT содержится новая версия ресурса целиком.

Если мы хотим зарегистрировать сразу несколько методов, можем использовать match:
    Route::match(['get', 'post'],  'url', 'function');

Если мы хотим зарегистрировать сразу все методы по руту:
    Route::any('url', 'function')

Любые HTML формы, указывающие на маршруты POST, PUT, PATCH, DELETE - должны быть защищены системой csrf
Для этого в HTML форме достаточно указать '@csrf' сразу после объявления формы

Если мы хотим перенаправить пользователя с одного url на другой - используем redirect:
    Route::redirect('current_url', 'new_url');
По умолчанию возвращается код 302, но его можно переопределить:
    Route::redirect('current_url', 'new_url', 301);
Если нужно вернуть только код состояния, используем permanentRedirect:
    Route::permanentRedirect('current_url', 'new_url');

В дальнейшем слова 'HTML шаблон' я буду заменить на 'вьюха'
Если мы хотим вернуть по определенному url вьюху, то используем view:
    Route::view('url', 'name_of_the_view');
Если нужно передать какие-то параметры во вьюхе, используем:
    Route::view('url', 'name_of_the_view', ['name_of_the_value' => 'value']);

Если нам нужно указывать в url какой-либо параметры типа ID пользователя или номер блога, используем:
    Route::get('url/{value}', function($value) {
        return 'User: ' . $value;
    });

Можно передавать сразу несколько параметров:
    Route::get('url/{some_value}/comments/{some_another_value}', function($some_value, $some_another_value) {
        return 'User: ' . $value . ' Post: ' . $some_another_value;
    });

Если параметр не всегда должен/может присутствовать в маршруте, используем '?':
    Route::get('/url/{value?}' , function($value = null) {
        return $value;
    });
    Route::get('/url/{value?}' , function($value = 'value') {
        return $value;
    });

Можно передать какие-то ограничения по регулярному выражению с помощью '->where()':
    Route::get('/url/{value}', function ($value) {
        // some code
    })->where('value', '[A-Za-z]+');
    Route::get('/url/{value}', function ($value) {
        // some code
    })->where('value', '[0-9]+');
    Route::get('/url/{id}/{value}', function ($value) {
        // some code
    })->where([
        'id' => '[0-9]+'
        'value' => '[0-9]+'
        ]);

Также есть шаблонные правила типа whereNumber, whereAlpha, whereAlphaNumeric:
    Route::get('/url/{id}', function($id) {
        // some code
    })->whereNumber('id');
Если входные значения не пройдут валидацию - будет возвращена 404 ошибка

-----------------------------------------------------------------------------------------------------------
Префиксы для URL
-----------------------------------------------------------------------------------------------------------
Мы можем добавить префикс для группы маршрутов, используем:
Route::prefix('name_of_the_prefix')->group(function() {
    Route::
    Route::
    Route::
});
Тогда мы сможем получить доступ к этим маршрутов по URL:
domain.com/name_of_the_prefix/url

-----------------------------------------------------------------------------------------------------------
Префиксы для ROUTES
-----------------------------------------------------------------------------------------------------------
Мы можем добавить префикс для имен маршрутов, используем:
Route::name('name_of_the_prefix.')->group(function() {
    Route:: -> name('some_name_1');
    Route:: -> name('some_name_2');
    Route:: -> name('some_name_3');
});
Тогда мы сможем получить доступ к этим маршрутам:
    route('name_of_the_prefix.name_of_the_route');

-----------------------------------------------------------------------------------------------------------
Глобальные ограничения
-----------------------------------------------------------------------------------------------------------
Можно поставить определенные ограничения по всем routes в файле RouteServiceProvider в методе boot():
    public function boot()
    {
        Route::pattern('id', '[0-9]+');
    }

-----------------------------------------------------------------------------------------------------------
Именование маршрутов
-----------------------------------------------------------------------------------------------------------
Имена маршрутов всегда должны быть уникальными

Чтобы иметь доступ к маршрутам во views, controller, jobs, commands, events, observers, action-classes, models
(обо всех этих матерных словах позже), можно задать имя маршруту
    Route::get('/url', 'function')->name('name');

Чтобы перенаправить на какой-то route, можем использовать только имя маршрута:
    return redirect()->route('profile');

Можно передать параметры в маршрут, используя имя маршрута:
    Route::get('/url/{id}', function($id) {
        // some logic
    })->name('some_name');

    $url = route('some_name', ['id' => 1]);

Можно передать еще параметры, даже если их нет в самом маршруте, тогда они будут добавлены в url таким образом:
    Route::get('/user/{id}/profile', function ($id) {
        //
    })->name('profile');

    $url = route('profile', ['id' => 1, 'photos' => 'yes']);
    // /user/1/profile?photos=yes

-----------------------------------------------------------------------------------------------------------
Кэширование маршрутов
-----------------------------------------------------------------------------------------------------------
Использования кэша маршрутов гораздо сократит загрузку той или иной страницы.
Чтобы сгенерировать кэш маршрута:
    php artisan route:cache

Но после изменения routes (добавление нового рута, удаление или изменение рута),
кэш нужно обновить. Чтобы перезаписать cache используем всю ту же команду:
    php artisan route:cache

Чтобы очистить кэш маршрутов:
    php artisan route:clear

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                                Controllers
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Готовьтесь к тому, что вы будете переносить свою логику из callback функций в рутах, в контроллеры,
а потом из controllers в jobs, а потом из jobs в action классы, потому что так - ОПТИМИЗИРОВАННЕЕ! syka..
На моей личной практике я рефакторил весь проект уже 5 раз, по мере изучения Laravel.

Чтобы создать контроллер, используем:
    php artisan make:controller <NameController>
Хранятся они в каталоге app/Http/Controllers
По рекомендациям разработчиков laravel лучше создавать контроллеры со словом "Controller" в конце названия
UserController, AdminController

В контроллерах мы можем писать методы, которые будут исполняться, когда пользователь будет переходить по какому-то route.
Посмотрите файл RegisterController.php

Чтобы определить метод, который будет исполняться при переходе по руту, в самом объявлении рута пишем:
    Route::get('/url', [ControllerClass::class, 'name_of_the_method'])->name('some_name');

Т.е. когда входящий запрос будет совпадать с указанном URL, будет вызван метод 'name_of_the_method' контроллера 'ControllerClass',
также параметры маршрута будут переданы методу
Пример route с параметрами
    Route::get('/url/{id}', [Controller::class, 'name_of_the_method'])->name('some_name');

Тогда в методе в классе контроллера будем передавать этот 'id'
    public function name_of_the_method($id)
    {
        return $id;
    }

Контроллеры одиночного действия - это контроллеры, в которых есть только 1 магический метод - __invoke
Помним из ООП, __invoke - magic method. Он будет исполнен, если не будет найден ни один подходящий метод
Тогда как зарегистрировать этот метод в route? Очень просто, его вообще указывать не нужно
    Route::post('/url', ControllerClass:: class)->name('some_name');

Чтобы сразу сгенерировать контроллер одиночного действия, нужно просто написать:
    php artisan make:controller NameController --invokable

Ресурсный контроллер - это контроллер, у которого есть все основные методы, отвечающие на GET, PUT, POST.. запросы
Чтобы создать такой контроллер, используем:
    php artisan make:controller NameController --resource

Можно зарегистрировать ресурсный route, используя:
    Route::resource('/url', NameController::class);

Пока не напишешь говно-код, не поймешь что такое говно-код. © Daniil Boyko
К чему я это? А к тому, что можно и объявлять несколько ресурсных контроллеров сразу
    Route::resources([
        '/photos' => PhotoController::class,
        '/posts' => PostController::class,
    ]);
Но это bad pattern, никогда так не делайте, иначе при удалении какого-либо из методов в одном из этих контроллеров,
придется вытягивать это из массива, переписывать руты

Действия, выполняемые ресурсными контроллерами
Метод	        URI	               Действие	        Имя маршрута
GET	        /photos	                index	        photos.index
GET	        /photos/create	        create	        photos.create
POST	    /photos	                store	        photos.store
GET	        /photos/{photo}	        show	        photos.show
GET	        /photos/{photo}/edit	edit	        photos.edit
PUT/PATCH	/photos/{photo}	        update	        photos.update
DELETE	    /photos/{photo}	        destroy	        photos.destroy

Никто не ограничивает вас в том, чтобы добавить новые методы в ресурсный или какой-либо другой контроллер
Точно также
1) Добавляем метод в контроллер, пишем логику в методе
2) Добавляем его в рутах и все

Там дальше идет взаимодействие с service container и eloquent моделями, но пока, как я понимаю,
это темный лес, поэтому пока закончу на этом свой рассказ

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                                Middlewares
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Переходим к страшному слову middleware
По-быстрому что это и зачем нужно:
Мы хотим перейти на какой-то рут, чтобы увидеть вьюху или отправить какие-то данные в форме (например, зарегистрироваться)
Наверняка слышали о MVC - Model View Controller

Для себя я объяснил это так:
    У нас есть три этапа жизни запроса
    1) Отправка самого запроса
    2) Валидация данных
    3) Получение результата в контроллере
Вот то, что делает middleware - находится между 1 и 2 пунктом. По-русски middleware - посредник.
Сейчас легкое объяснение, по которому поймете. Например, middleware 'auth'
Он проверяет авторизирован ли пользователь в нашем приложении, если ответ положительный - он перенаправляет запрос в контроллер.
Надеюсь понятно, что это чистый приспособленец валидации

Чтобы создать middleware, используем:
php artisan make:middleware NameMiddleware
Опять же, в конце названия middleware (посредника) - надо писать слово Middleware, чтобы в первую очередь вам было легче потом искать конкретный файл
Но просто создать middleware и написать там логику - мало, надо его еще зарегистрировать.
Где регистрировать?
    Ответ: в app/Http/Kernel.php

Коротко о том, что находится в этом файле:
В свойстве $routeMiddleware содержатся уже зарегистрированные Laravel middlewares, которые идут из коробки
Можем добавить туда свой middleware:
    'alias' => NameMiddleware::class,

Написали логику в посреднике, зарегистрировали его, а как применять? Вот так:
    Route::get('/url', function() {
        // some code
    }->middleware('alias');

Если вам одного посредника мало, вы абьюзер и хотите еще больше ограничить права людей, то вот как применять сразу несколько посредников на один маршрут:
    Route::get('/url', function() {
        // some code
    }->middleware(['alias_1', 'alias_2']);

Но можно и не указывать алиасы, а просто передать instance:
    Route::get('/url', function() {
         // some code
    }->middleware(NameMiddleware::class);

Помните в разделе про руты, можно было группировать маршруты, так вот можно и применять middleware сразу на всю группу маршрутов:
    Route::prefix('name_of_the_prefix')->group(function() {
        Route::middleware([NameMiddleware::class])->group(function() {
            Route:: ;
            Route:: ;
            Route:: ;
        });
    });

Не хотите так? Можно и так:
    Route::prefix('name_of_the_prefix')->group(function() {
        Route::group(['middleware' => NameMiddleware::class], function() {
            Route:: ;
            Route:: ;
            Route:: ;
        });
    });

Может быть такая ситуация, когда какой-то маршрут из группы не вынесешь, потому что будет не очень красиво,
тогда можно исключить middleware для этого рута:
    Route::prefix('name_of_the_prefix')->group(function() {
        Route::group(['middleware' => NameMiddleware::class], function() {
            Route:: ;
            Route:: ;
            Route::get('/url', function() {
                // some code here
            })->withoutMiddleware([NameMiddleware::class]);
        });
    });

Пойдем дальше по файлу Kernel.php - его кстати называют HTTP ядром приложения
    Свойство $middlewareGroups. Зачем нужно? У нас ведь есть alias для какого-то конкретного посредника (в свойстве $routeMiddleware),
    так вот можно назначить несколько посредников сразу под один alias. Надеюсь, догадаетесь как добавлять -_-

    Ну тогда и применять эти middlewares будем по одному alias:
        Route::get('/url', function () {
            // some code here
        })->middleware('alias');
    Ну или так, никакой разницы:
        Route::middleware(['alias'])->group(function() {
            Route::get('/url', function () {
                // some code here
            }
        }

Далее есть предопределенное свойство $middlewarePriority. Зайди посмотри, что там перечислено.

Ха-ха-ха-ха. Гы. Его там нет, иди сюда обратно. Ну и куда ты пошел смотреть его?
Это свойство нужно объявить, если тебе важен порядок выполнения middleware. На моей практике не требовалось этого.
