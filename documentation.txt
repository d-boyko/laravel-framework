# Laravel Framework Documentation
was made according to self-improvement spreadsheet

Рекомендую курсы:
Max Orlov - Laravel
Cutcode - Laravel

App structure - 15 row
Routes - 226 row
Controllers - 417 row
Middlewares - 504 row
Views - 617 row
Models - 713 row

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                           App structure
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
app {
    Весь основной код приложения
    Console {
        Все что необходимо для обработки commands (стандартных и кастомных)
        Kernel.php {
            Регистрация кастомных commands
        }
    }
    Events {
        Входит в раздел слушатели и события. Слушатели и события объявляются в EventServiceProvider.php
    }
    Http {
        Controllers {
            Обработка запросов на отображение, создание, обновление и удаление пользователей
        }
        Middleware {
            MIDDLEWARE - ПРОМЕЖУТОЧНЫЙ СЛОЙ МЕЖДУ ВХОДЯЩИМ ЗАПРОСОМ И КОНТРОЛЛЕРОМ
            Можно записать логи, добавить к ответу файлы куки и т.п.
            Authenticate - вошел пользователь или не вошел
            EncryptCookies - когда запрос с куками прилетает в наше приложение - он расшифровывает их, а на выходе - шифрует
            PreventRequestsDuringMaintenance - находится ли наше приложение в режиме обслуживания при каком-либо запросе
            php artisan down - включает режим обслуживания
            RedirectIfAuthenticated - если юзер уже вошел в систему - перекидывает в личный кабинет
            TrimStrings - если была отправлена форма регистрации, может быть такое что юзер прислал email с пробелом в конце,
            этот middleware обрезает пробелы в начале и в конце полей
            TrustHosts - хосты с которыми будет взаимодействовать приложение
            TrustProxies - сервер-балансировщик распределяет все запросы поровну на сервера приложения
            VerifyCsrfToken - защита от Csrf атаки (подделка межсайтовых запросов). Нужно соблюдать его при использовании форм
            POST, PUT, DELETE | @csrf
        }
        Requests {
            Другая форма для правил валидации. Чтобы не писать логику валидации в контроллере - можем создать отдельный класс, в котором в методе
            "rules" будут перечислены правила валидации
        }
        Kernel.php {
            Все что необходимо для обработки HTTP запросов
            Настройка middleware - классов которые обрабатывают запрос, прежде чем он попадает в контроллер
        }
    }
    Jobs {
        Создание jobs
    }

    Listeners {
        Слушатели событий, объявляются в EventServiceProvider.php
    }
    Mail {
        При запуске команды php artisan make:mail {name}. Служит для отправки уведомлений на почту
    }
    Models {
        Модели приложения, с помощью которых можно задать конфигурацию на относящийся к ним таблицы и взаимодействовать с ними
    }
    Providers {
        Системные конфигурируемые настройки
        AppServiceProvider {
            В методе "boot" можно задать настройки для вьюх и т.д.
        }
        EventServiceProvider {
            Регистрация слушателей и событий
        }
        RouteServiceProvider {
            Можно задать новые пути для рутов, если мы хотим разделить их на несоклько файлов
        }
    }
    Rules {
        Можно задать дополнительные правила валидации, которые потом сможем использовать в контроллере или в Requests
    }
    Scopes {
        Можно задать условии, по котором при обращении к модели будут браться определенные данные (например при запросах SELECT, UPDATE, DELETE)
    }
}

bootstrap {
    app.php {
        Главный файл по запуску приложения. С этого файла начинается работа всего фреймворка
        В переменную $app кладется экземпляр самого приложение, регистрируется HTTP и консольные ядра
        Возвращается экземпляр приложения
    }
    cache {
        Этот каталог входит в gitignore, там фреймворк делает какие-то свои операции, которые не будут видны в репозитории
    }
}

config {
    Просто множество файлов конфигурации
    Можно создавать свои файлы конфигурации
}

database {
    Создаются файлы для работы с базой данных
    factories {
        Содержится конфиг для сидинга базы данных
    }
    migrations {
        Миграции к базе данных
    }
    seeders {
        Сиды для базы данных, которые используют фабрики
    }
}

lang {
    Содержит настройку по языку проекта
}

public {
    Содержит в себе публичные файлы
    Все запросы которые приходят от браузера должны попадать в файл index.php
    Берем HTTP ядро и запускаем обработку запроса.
}

resources {
    css, js {
        Исходные стили для страничек
    }
    views {
        Все странички сайта
        components {
            Работает как интерфейсы в ООП, только с небольшой реализацией и начальными параметрами
        }
    }
}

routes {
    Можно создавать свои файлы для маршрутизации
    api.php {
        Маршруты для API
    }

    console.php {
        Мы можем создавать свои команды, но лучше это делать с помощью php artisan make:command <> -> тогда этот файла попадет
        в app/Console/Command
    }

    channels.php {
        Позволяет регистрировать каналы, проверять доступы пользователей к тому или иному каналу
    }

    web.php {
        Маршруты для браузера
    }
}

storage {
    app {
        public {
            Если пользователь загружает аватарку - она попадает сюда
        }
    }

    framework {
        Закэшированные шаблоны для оптимизации
    }

    logs {
        Если возникает какая-то ошибка - можно поискать и найти ее там
    }
}

tests {
    Юнит и Фича тесты
}

vendor {
    Пакеты и зависимости композера
    Исходный код фреймворка в поддиректории laravel
}

.editorconfig {
    Параметры для редактора кода
}

.env {
    Добавлен в .gitignore, переменная окружения
}

.env.example {
    Его нет в .gitignore, это просто шаблон .env
}

.gitignore {
    Добавляем файлы в .gitignore
}

artisan {
    Когда мы выполняем команду php artisan... берем app.php, берем консольное ядро Kernel и обрабатываем команду
}

AboutFiles.txt {
    То что ты читаешь сейчас --__--
}

composer.json {
    Перечислены все пакеты которые нужны для работы нашего проекта
}

composer.lock {
    Фиксирование тех зависимостей и версий которые у нас остановлены
}

package.json {
    Для пакетов которые установлены через npm
}

phpunit.xml {
    Параметры для тестирования
}

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                                  Routes
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Руты это не рут права на андроиде при взламывании игр. © Daniil Boyko

Пример route с callback функцией:
    Route::get('/hello', function() {
        return 'Hello World';
    });
Следовательно, после перехода в браузере на url: 127.0.0.1:8000/hello - мы увидим надпись Hello World.

По умолчанию все routes находятся в файле routes/web.php
Мы можем зарегистрировать новый файл в RouteServiceProvider.php
    Route::middleware('web')
        ->group(function() {
            require base_path('routes/web.php');
            require base_path('routes/admin.php');
            require base_path('routes/user.php');
        });
О страшном слове middleware позже.

-----------------------------------------------------------------------------------------------------------
Routes types:
    Route::get('url', 'function');
    Route::post('url', 'function');
    Route::put('url', 'function');
    Route::patch('url', 'function');
    Route::delete('url', 'function');
    Route::options('url', 'function');
-----------------------------------------------------------------------------------------------------------
GET метод позволяет получить все то, что нельзя никак отредактировать, добавить, удалить и так далее (к примеру HTML странички)
POST - может использоваться также для редактирования ресурса
PUT - для редактирования ресурса
DELETE - удаление ресурса
OPTIONS - представляет запрос информации об опциях соединения, доступных в цепочке запросов/ответов (короче конфиг)

Вроде с помощью POST можно редактировать какую-то запись и с помощью PUT, так в чем же разница?
    Представь, что у нас есть сервис с блогом и постами. В одном блоге может быть несколько постов.
    Для добавления нового поста мы конечно используем метод POST с url например: domain.com/blogs/id
    После создания нового поста метод POST сам создаст URL и вернет этот URL для доступа к нему через GET или для удаления через DELETE

    А теперь допустим, что такой пост уже создан и клиент хочет просто отредактировать его (исправить синтаксическую ошибку например)
    То есть другими словами, клиент хочет ПЕРЕЗАПИСАТЬ пост
    Для этого будет использован метод PUT с URL: domain.com/blogs/id/posts/post_id, он передает обновленную запись в теле запроса
    Сервис, ориентируясь на метод PUT удаляет старую запись и перезаписывает новую, при этом этот пост доступен по тому же URL

    Нет конкретного правила на использования POST и PUT, но все же стоит придерживаться рекомендаций в целях единообразной трактовки
    методов всеми разработчиками

    Смотрел форум по презентации LARAVEL 9, там говорилось о том, что рекомендуется использовать POST для создания подчиненного ресурса
    (все на том же примере: в блоге много постов, значит посты - подчиненный ресурс)

PATCH используется для частичного изменения ресурса. PUT создает новый ресурс или заменяет представление целевого ресурса, данными представленными в теле запроса.
Другими словами, PATCH вложенный объект содержит набор инструкций, описывающих, как ресурс,
находящийся в данный момент на исходном сервере, должен быть модифицирован для создания новой версии.
А в PUT содержится новая версия ресурса целиком.

Если мы хотим зарегистрировать сразу несколько методов, можем использовать match:
    Route::match(['get', 'post'],  'url', 'function');

Если мы хотим зарегистрировать сразу все методы по руту:
    Route::any('url', 'function')

Любые HTML формы, указывающие на маршруты POST, PUT, PATCH, DELETE - должны быть защищены системой csrf
Для этого в HTML форме достаточно указать '@csrf' сразу после объявления формы

Если мы хотим перенаправить пользователя с одного url на другой - используем redirect:
    Route::redirect('current_url', 'new_url');
По умолчанию возвращается код 302, но его можно переопределить:
    Route::redirect('current_url', 'new_url', 301);
Если нужно вернуть только код состояния, используем permanentRedirect:
    Route::permanentRedirect('current_url', 'new_url');

В дальнейшем слова 'HTML шаблон' я буду заменить на 'вьюха'
Если мы хотим вернуть по определенному url вьюху, то используем view:
    Route::view('url', 'name_of_the_view');
Если нужно передать какие-то параметры во вьюхе, используем:
    Route::view('url', 'name_of_the_view', ['name_of_the_value' => 'value']);

Если нам нужно указывать в url какой-либо параметры типа ID пользователя или номер блога, используем:
    Route::get('url/{value}', function($value) {
        return 'User: ' . $value;
    });

Можно передавать сразу несколько параметров:
    Route::get('url/{some_value}/comments/{some_another_value}', function($some_value, $some_another_value) {
        return 'User: ' . $value . ' Post: ' . $some_another_value;
    });

Если параметр не всегда должен/может присутствовать в маршруте, используем '?':
    Route::get('/url/{value?}' , function($value = null) {
        return $value;
    });
    Route::get('/url/{value?}' , function($value = 'value') {
        return $value;
    });

Можно передать какие-то ограничения по регулярному выражению с помощью '->where()':
    Route::get('/url/{value}', function ($value) {
        // some code
    })->where('value', '[A-Za-z]+');
    Route::get('/url/{value}', function ($value) {
        // some code
    })->where('value', '[0-9]+');
    Route::get('/url/{id}/{value}', function ($value) {
        // some code
    })->where([
        'id' => '[0-9]+'
        'value' => '[0-9]+'
        ]);

Также есть шаблонные правила типа whereNumber, whereAlpha, whereAlphaNumeric:
    Route::get('/url/{id}', function($id) {
        // some code
    })->whereNumber('id');
Если входные значения не пройдут валидацию - будет возвращена 404 ошибка

-----------------------------------------------------------------------------------------------------------
Префиксы для URL
-----------------------------------------------------------------------------------------------------------
Мы можем добавить префикс для группы маршрутов, используем:
Route::prefix('name_of_the_prefix')->group(function() {
    Route::
    Route::
    Route::
});
Тогда мы сможем получить доступ к этим маршрутов по URL:
domain.com/name_of_the_prefix/url

-----------------------------------------------------------------------------------------------------------
Префиксы для ROUTES
-----------------------------------------------------------------------------------------------------------
Мы можем добавить префикс для имен маршрутов, используем:
Route::name('name_of_the_prefix.')->group(function() {
    Route:: -> name('some_name_1');
    Route:: -> name('some_name_2');
    Route:: -> name('some_name_3');
});
Тогда мы сможем получить доступ к этим маршрутам:
    route('name_of_the_prefix.name_of_the_route');

-----------------------------------------------------------------------------------------------------------
Глобальные ограничения
-----------------------------------------------------------------------------------------------------------
Можно поставить определенные ограничения по всем routes в файле RouteServiceProvider в методе boot():
    public function boot()
    {
        Route::pattern('id', '[0-9]+');
    }

-----------------------------------------------------------------------------------------------------------
Именование маршрутов
-----------------------------------------------------------------------------------------------------------
Имена маршрутов всегда должны быть уникальными

Чтобы иметь доступ к маршрутам во views, controller, jobs, commands, events, observers, action-classes, models
(обо всех этих матерных словах позже), можно задать имя маршруту
    Route::get('/url', 'function')->name('name');

Чтобы перенаправить на какой-то route, можем использовать только имя маршрута:
    return redirect()->route('profile');

Можно передать параметры в маршрут, используя имя маршрута:
    Route::get('/url/{id}', function($id) {
        // some logic
    })->name('some_name');

    $url = route('some_name', ['id' => 1]);

Можно передать еще параметры, даже если их нет в самом маршруте, тогда они будут добавлены в url таким образом:
    Route::get('/user/{id}/profile', function ($id) {
        //
    })->name('profile');

    $url = route('profile', ['id' => 1, 'photos' => 'yes']);
    // /user/1/profile?photos=yes

-----------------------------------------------------------------------------------------------------------
Кэширование маршрутов
-----------------------------------------------------------------------------------------------------------
Использования кэша маршрутов гораздо сократит загрузку той или иной страницы.
Чтобы сгенерировать кэш маршрута:
    php artisan route:cache

Но после изменения routes (добавление нового рута, удаление или изменение рута),
кэш нужно обновить. Чтобы перезаписать cache используем всю ту же команду:
    php artisan route:cache

Чтобы очистить кэш маршрутов:
    php artisan route:clear

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                                Controllers
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Контролируем маршруты контроллерами. © Daniil Boyko

Готовьтесь к тому, что вы будете переносить свою логику из callback функций в рутах, в контроллеры,
а потом из controllers в events, из events в observers, из observers в jobs, а потом из jobs в action классы, потому что так - ОПТИМИЗИРОВАННЕЕ! syka...
Обо всех страшных словах потом, пока ты не готов.
На моей личной практике я рефакторил весь проект уже 5 раз, по мере изучения Laravel.

-----------------------------------------------------------------------------------------------------------
Создание контроллера
-----------------------------------------------------------------------------------------------------------
Чтобы создать контроллер, используем:
    php artisan make:controller <NameController>
Хранятся они в каталоге app/Http/Controllers
По рекомендациям разработчиков laravel лучше создавать контроллеры со словом "Controller" в конце названия
UserController, AdminController

-----------------------------------------------------------------------------------------------------------
Базовые понятия
-----------------------------------------------------------------------------------------------------------
В контроллерах мы можем писать методы, которые будут исполняться, когда пользователь будет переходить по какому-то route.
Посмотрите файл RegisterController.php

Чтобы определить метод, который будет исполняться при переходе по руту, в самом объявлении рута пишем:
    Route::get('/url', [ControllerClass::class, 'name_of_the_method'])->name('some_name');

Т.е. когда входящий запрос будет совпадать с указанном URL, будет вызван метод 'name_of_the_method' контроллера 'ControllerClass',
также параметры маршрута будут переданы методу
Пример route с параметрами
    Route::get('/url/{id}', [Controller::class, 'name_of_the_method'])->name('some_name');

Тогда в методе в классе контроллера будем передавать этот 'id'
    public function name_of_the_method($id)
    {
        return $id;
    }

-----------------------------------------------------------------------------------------------------------
Контроллеры одиночного действия
-----------------------------------------------------------------------------------------------------------
Контроллеры одиночного действия - это контроллеры, в которых есть только 1 магический метод - __invoke
Помним из ООП, __invoke - magic method. Он будет исполнен, если не будет найден ни один подходящий метод
Тогда как зарегистрировать этот метод в route? Очень просто, его вообще указывать не нужно
    Route::post('/url', ControllerClass:: class)->name('some_name');

Чтобы сразу сгенерировать контроллер одиночного действия, нужно просто написать:
    php artisan make:controller NameController --invokable

-----------------------------------------------------------------------------------------------------------
Ресурсные контроллеры
-----------------------------------------------------------------------------------------------------------
Ресурсный контроллер - это контроллер, у которого есть все основные методы, отвечающие на GET, PUT, POST.. запросы
Чтобы создать такой контроллер, используем:
    php artisan make:controller NameController --resource

Можно зарегистрировать ресурсный route, используя:
    Route::resource('/url', NameController::class);

Пока не напишешь говно-код, не поймешь что такое говно-код. © Daniil Boyko
К чему я это? А к тому, что можно и объявлять несколько ресурсных контроллеров сразу
    Route::resources([
        '/photos' => PhotoController::class,
        '/posts' => PostController::class,
    ]);
Но это bad pattern, никогда так не делайте, иначе при удалении какого-либо из методов в одном из этих контроллеров,
придется вытягивать это из массива, переписывать руты

Действия, выполняемые ресурсными контроллерами
Метод	        URI	               Действие	        Имя маршрута
GET	        /photos	                index	        photos.index
GET	        /photos/create	        create	        photos.create
POST	    /photos	                store	        photos.store
GET	        /photos/{photo}	        show	        photos.show
GET	        /photos/{photo}/edit	edit	        photos.edit
PUT/PATCH	/photos/{photo}	        update	        photos.update
DELETE	    /photos/{photo}	        destroy	        photos.destroy

Никто не ограничивает вас в том, чтобы добавить новые методы в ресурсный или какой-либо другой контроллер
Точно также
1) Добавляем метод в контроллер, пишем логику в методе
2) Добавляем его в рутах и все

Там дальше идет взаимодействие с service container и eloquent моделями, но пока, как я понимаю,
это темный лес, поэтому пока закончу на этом свой рассказ

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                                Middlewares
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Волк не тот, кто работает с данными. Волк тот, кто работает с данными. © Daniil Boyko

Переходим к страшному слову middleware

-----------------------------------------------------------------------------------------------------------
Базовые понятия
-----------------------------------------------------------------------------------------------------------
По-быстрому что это и зачем нужно:
Мы хотим перейти на какой-то рут, чтобы увидеть вьюху или отправить какие-то данные в форме (например, зарегистрироваться)
Наверняка слышали о MVC - Model View Controller

Для себя я объяснил это так:
    У нас есть три этапа жизни запроса
    1) Отправка самого запроса
    2) Валидация данных
    3) Получение результата в контроллере
Вот то, что делает middleware - находится между 1 и 2 пунктом. По-русски middleware - посредник.
Сейчас легкое объяснение, по которому поймете. Например, middleware 'auth'
Он проверяет авторизирован ли пользователь в нашем приложении, если ответ положительный - он перенаправляет запрос в контроллер.
Надеюсь понятно, что это чистый приспособленец валидации

-----------------------------------------------------------------------------------------------------------
Создание middleware
-----------------------------------------------------------------------------------------------------------
Чтобы создать middleware, используем:
php artisan make:middleware NameMiddleware
Опять же, в конце названия middleware (посредника) - надо писать слово Middleware, чтобы в первую очередь вам было легче потом искать конкретный файл
Но просто создать middleware и написать там логику - мало, надо его еще зарегистрировать.
Где регистрировать?
    Ответ: в app/Http/Kernel.php

Коротко о том, что находится в этом файле:
В свойстве $routeMiddleware содержатся уже зарегистрированные Laravel middlewares, которые идут из коробки.
Можем добавить туда свой middleware:
    'alias' => NameMiddleware::class,

-----------------------------------------------------------------------------------------------------------
Использование middleware
-----------------------------------------------------------------------------------------------------------
Написали логику в посреднике, зарегистрировали его, а как применять? Вот так:
    Route::get('/url', function() {
        // some code
    }->middleware('alias');

Если вам одного посредника мало, вы абьюзер и хотите еще больше ограничить права людей, то вот как применять сразу несколько посредников на один маршрут:
    Route::get('/url', function() {
        // some code
    }->middleware(['alias_1', 'alias_2']);

Но можно и не указывать алиасы, а просто передать instance:
    Route::get('/url', function() {
         // some code
    }->middleware(NameMiddleware::class);

Помните в разделе про руты, можно было группировать маршруты, так вот можно и применять middleware сразу на всю группу маршрутов:
    Route::prefix('name_of_the_prefix')->group(function() {
        Route::middleware([NameMiddleware::class])->group(function() {
            Route:: ;
            Route:: ;
            Route:: ;
        });
    });

Не хотите так? Можно и так:
    Route::prefix('name_of_the_prefix')->group(function() {
        Route::group(['middleware' => NameMiddleware::class], function() {
            Route:: ;
            Route:: ;
            Route:: ;
        });
    });

Может быть такая ситуация, когда какой-то маршрут из группы не вынесешь, потому что будет не очень красиво,
тогда можно исключить middleware для этого рута:
    Route::prefix('name_of_the_prefix')->group(function() {
        Route::group(['middleware' => NameMiddleware::class], function() {
            Route:: ;
            Route:: ;
            Route::get('/url', function() {
                // some code here
            })->withoutMiddleware([NameMiddleware::class]);
        });
    });

-----------------------------------------------------------------------------------------------------------
Группы of middlewares
-----------------------------------------------------------------------------------------------------------
Пойдем дальше по файлу Kernel.php - его кстати называют HTTP ядром приложения
    Свойство $middlewareGroups. Зачем нужно? У нас ведь есть alias для какого-то конкретного посредника (в свойстве $routeMiddleware),
    так вот можно назначить несколько посредников сразу под один alias. Надеюсь, догадаетесь как добавлять -_-

    Ну тогда и применять эти middlewares будем по одному alias:
        Route::get('/url', function () {
            // some code here
        })->middleware('alias');
    Ну или так, никакой разницы:
        Route::middleware(['alias'])->group(function() {
            Route::get('/url', function () {
                // some code here
            }
        }

-----------------------------------------------------------------------------------------------------------
Приоритетность посредников
-----------------------------------------------------------------------------------------------------------
Далее есть предопределенное свойство $middlewarePriority. Зайди и посмотри, что там перечислено.

Гы. Его там нет, иди сюда обратно. Ну и куда ты пошел смотреть его?
Это свойство нужно объявить, если тебе важен порядок выполнения middleware. На моей практике не требовалось этого.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                                Views
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Только дед инсайды возвращают в callback функциях HTML-код. © Daniil Boyko

-----------------------------------------------------------------------------------------------------------
Базовые понятия
-----------------------------------------------------------------------------------------------------------
Все шаблонные представления (далее вьюхи) располагаются в каталоге resources/views/
Чтобы вьюха была доступна по руту, для начала как бы ее надо создать.
Про то, почему шаблонизатор '.blade.php' лучше простого HTML - потом.
После создания, вьюху можно получить так:
    Route::get('/url', function() {
        return view('name_of_the_view');
    });

Либо можно использовать фасад View:
    Route::get('/url', function() {
        return View::make('name_of_the_view');
    });

Чтобы передать какой-то параметр во вьюху, используем:
    Route::get('/url/', function() {
        return view('name_of_the_view', ['name' => 'Danya']);
    });
    И в самой вьюхе тогда:
    <html>
        <body>
            <h1>Привет, {{ $name }}</h1>
        </body>
    </html>

-----------------------------------------------------------------------------------------------------------
Получение вьюхи из поддиректорий
-----------------------------------------------------------------------------------------------------------
Рассмотрим кейс, если у нас есть поддиректория в каталоге views. Например /resources/views/admin/index.blade.php
Тогда возврат вьюхи будет выглядеть так:
    Route::get('/url', function() {
        return view('admin.index');
    });

Честно, следующий кейс не знаю когда может применяться, но запихну его сюда.
    Route::get('/url', function() {
        if (View::exists('name_of_the_view')) {
            return view('name_of_the_view');
        } else {
            abort(403);
        }
    });
Это типо если вы не знаете есть вьюха или нет, но понятия не имею как разработчик может не знать какие вьюхи есть в проекте, а какие нет.
В sxope-ocean нет ни одного такого примера.

Есть еще способ как передать данные во вьюху:
    Route::get('/url', function() {
        return view('admin.index')
            ->with('name', 'Danya')
            ->with('surname', 'Boyko');
    });

-----------------------------------------------------------------------------------------------------------
Передача данных из контроллера во вьюху
-----------------------------------------------------------------------------------------------------------
1) Объявили рут:
    Route::get('/test-data-to-view', [UserController::class, 'testDataToView'])->name('test-data-to-view');

2) Написали метод в контроллере. Вот, то как правильнее передавать данные во вьюху. Не знаю почему, но ->with у меня не всегда работает. С чем связано - не знаю.
    public function testDataToView()
    {
        $id = 123123123;
        return view('views-tester', compact('id'));
    }
3) Вывели это в /resources/views/views-tester.blade.php
    {{ $id }}

-----------------------------------------------------------------------------------------------------------
Шаринг данных на все вьюхи
-----------------------------------------------------------------------------------------------------------
Бывают такие кейсы, когда данные должны передаваться во все вьюхи сразу, а если таких вьюх тысяча, то что делать?
Правильно, зарегистрировать эти переменные и значения в AppServiceProvider.php в методе 'boot'. Ага, так ты и ответил, конечно.
    public function boot()
    {
        View::share('key', 'value');
    }

-----------------------------------------------------------------------------------------------------------
Кэширование вьюх
-----------------------------------------------------------------------------------------------------------
Честно, это заеб. Ничего больше не могу сказать. Кэшировать то легко, но точно как в случае с рутами:
При каждом изменении во вьюхе, нужно будет переопределять кэш, чтобы увидеть окончательный результат.
Считаю, что кэширование нужно на каких-то крупных сервисах, потому что это оптимизация, на localhost это ни к чему.
Но все же, чтобы закэшировать вьюхи, используем:
    php artisan view:cache

Очистить кэш вьюх:
    php artisan view:clear

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                                Models
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Laravel модель это не Kylie Jenner, но поебаться с этим стоит. © Daniil Boyko

-----------------------------------------------------------------------------------------------------------
Базовые понятия
-----------------------------------------------------------------------------------------------------------
Laravel содержит ORM-библиотеку Eloquent. Все дружно поняли, что такое ORM-библиотеку, ага, конечно.
ORM - Object Relational Mapping, это библиотека, которая позволяет взаимодействовать с базой данных в рамках концептах ООП.
Также это может означать Object Role Model. При использовании Eloquent каждая таблица БД имеет Модель, которая используется
для взаимодействия с таблицей.
Создайте базу mysql, вот мои конфиг в .env:
    DB_CONNECTION=mysql
    DB_HOST=127.0.0.1
    DB_PORT=3306
    DB_DATABASE=laravel
    DB_USERNAME=root
    DB_PASSWORD=

-----------------------------------------------------------------------------------------------------------
Создание моделей
-----------------------------------------------------------------------------------------------------------
Чтобы создать модель, используем:
    php artisan make:model Post
Чтобы создать модель сразу с миграцией:
    php artisan make:model Post --migration
    php artisan make:model Post -m
Можно комбинировать флаги, например:
    php artisan make:model Post -mfsc - Это создает модель, миграцию, фабрику, сид, контроллер
О том, что такое фабрика и сид - позже.
Созданные модели находятся в app\Models.

-----------------------------------------------------------------------------------------------------------
Соглашение по именованию моделей
-----------------------------------------------------------------------------------------------------------
По умолчанию при создании модели Post, Laravel подразумевает, что эта модель будет связана с таблицей posts в базе данных
Тоже самое: модель User - табличка users

-----------------------------------------------------------------------------------------------------------
Конфигурация моделей
-----------------------------------------------------------------------------------------------------------
Бывают такие кейсы, в которых нужно другое название таблицы, например:
    Модель Post - таблица history_posts;
Тогда в классе модели можно просто указать protected свойство $table = 'history_posts';

Предполагается из коробки, что первичным ключом в каждой таблицы будет 'id', но если он у нас другой, то в классе модели:
    protected $primaryKey = 'another_name_of_primary_key';

Laravel также предполагает, что primary key является auto-incrementing (т.е. увеличивающимся автоматически на 1) integer.
Но если, например, у нас есть табличка currencies (валюты), то удобнее держать primary key в виде названия валюты, т.е string.
Тогда в модели указываем:
    public $incrementing = false;
    protected $keyType = 'string';

Составные первичные ключи не поддерживаются Eloquent, но можно создать дополнительные уникальные индексы к таблицам БД

В каждой табличке Laravel автоматически определит две колонки: created_at, updated_at. Если не хотим их видеть:
    public $timestamps = false;

Если мы хотим поменять формат даты в колонках:
    protected $dateFormat = 'U';

Если мы хотим изменить начальные имена created_at, updated_at колонок, то в классе модели:
    CONST CREATED_AT = 'creation_date';
    CONST UPDATED_AT = 'updated_date';

Если хотим указать не дефолтное значение в подключении к БД, то:
    protected $connection = 'another_connection';

Если хотим указать стандартное значение для определенных полей, то:
    protected $attributes = [
        'name' => 'Danya';
    ];


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                        Eloquent query builder
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Чтобы получить все записи таблички, связанной с моделью:
    $users = User::all();
    foreach($users as $user) {
        echo $user->name;
    }

Также можно получать записи с дополнительными условиями:
    $users = User::where('name', '=', 'John')
        ->orderBy('id')
        ->take(10)
        ->get();
Здесь
   WHERE - аналог WHERE в sql
   TAKE - аналог LIMIT
   GET - получение результатов

Метод refresh повторно обновит модель, используя свежие данные из БД:
    $flight = Flight::where('number', 'FR 900')->first();
    $flight->number = 'FR 456';
    $flight->refresh();
    $flight->number; // "FR 900"

Методы all и get возвращают не массив, а экземпляр класса Collection, который содержит много полезных методов.

Отображение записей, используя chunks, меньшее потребление памяти при работе с большим количеством моделей
    User::chunk(200, function($users) {
    foreach($users as $user)
        echo $user->name;
    });

Обновление, используя chunks, сортировка по Id
    User::where('is_active', '=', true)
        ->chunkById(200, function ($users)) {
            $users->each->update(['is_admin' => true]);
        }, $column = 'id')

Метод lazy работает концептуально как chunks, только с lazy вы работаете с единым потом, а chunks берет каждую модель отдельно
lazy возвращает экземпляр класса LazyCollection одноуровневых моделей Eloquent
    foreach(User::lazy() as $user) {
        // some code here
    }

Обновление, используя lazy, сортировка по Id
    User::where('is_active', '=', true)
        ->lazyById(200, function ($users)) {
            $users->each->update(['is_admin' => true]);
        }, $column = 'id')

Либо можно отфильтровать результаты по убыванию Id:
    User::where('is_active', '=', true)
        ->lazyByIdDesc(200, function ($users)) {
            $users->each->update(['is_admin' => true]);
        }, $column = 'id')

Отображение результатов с помощью курсора:
    $users = User::cursor()->filter(function ($user) {
        return $user->id > 500;
    });

    foreach ($users as $user) {
        echo $user->id;
    }

-----------------------------------------------------------------------------------------------------------
                                            Расширенные подзапросы
-----------------------------------------------------------------------------------------------------------
Eloquent также предлагает поддержку расширенных подзапросов, которая позволяет извлекать информацию из связанных таблиц в одном запросе.
Долго не мог понять как вывести это в обычный SQL-запрос, а потом просто нашел метод ->toSql()...
    Destination::addSelect(['last_flight' => Flight::select('name')
        ->whereColumn('destination_id', 'destinations.id')
        ->orderByDesc('arrived_at')
        ->limit(1)

    select `users`.*,
           (
            select
                `is_published`
            from
                `posts`
            ) as `is_published`
    from `users`
    where `posts`.`user_id` = `users`.`id`
      and `users`.`deleted_at` is null
    order by `email` desc
    limit 1

Кроме того, метод orderBy построителя запросов поддерживает подзапросы:
    User::orderByDesc(
                    Post::select('is_published')
                        ->whereColumn('user_id', 'users.id')
                        ->orderByDesc('is_published')
                        ->limit(1))
    select
        *
    from
        `users`
    where
        `users`.`deleted_at` is null
    order by
        (
            select
                `is_published`
            from
                `posts`
            where
                `user_id` = `users`.`id`
            order by
                `is_published` desc
            limit 1
        ) desc

Хотя метод cursor использует гораздо меньше памяти, чем обычный запрос (удерживая в памяти только одну модель Eloquent),
он все равно в конечном итоге может исчерпать память.
Если нужно работать с большим количеством записей - то используете lazy.

get() ->
    Работает быстро, но жрет много памяти, под капотом использует fetchAll, загружаю сразу все.
cursor() ->
    Работает медленно, но жрет мало памяти, под капотом использует fetch. Итерации выполняются одна за другой;
    Не загружает отношения;
    Не может работать с большими коллекциями, закончится память;
    Так как загрузка данных происходит только по одной записи за раз, это позволит сохранить согласованность при обработке наборов данных,
    которые могут измениться в процессе работы;
    Модели не будут включены, пока не будут фактически итерированы.
chunk() ->
    Меньше вызовов fetchAll, пытается разбить большой результат на маленькие, используя предел указанный тобой;
    В каком-то смысле chunk использует преимущества get() и cursor();
    Наименьшее использование памяти;
    Самый медленный способ;
    Если одновременно выполняем итерацию и обновляем данные, используй chunkById;
    Могут возникнуть проблемы при обновлении первичных и внешних ключей.
lazy() ->
   По сути, она делает то же самое, что и chunk(). Однако вам не нужен обратный вызов,
   поскольку он использует PHP-генераторы и возвращает LazyCollection, что делает синтаксис более чистым;
   Низкое использование памяти;
   Более приятный синтаксис, чем chunk();
   Если вы одновременно выполняете итерацию и обновление записей, используйте lazyById.

-----------------------------------------------------------------------------------------------------------
                                        Извлечение отдельных моделей
-----------------------------------------------------------------------------------------------------------
Получить модель по первичному ключу:
$user = User::find(1);

Получить первую модель, соответствующую условиям запроса:
$user = User::where('is_active', true)->first();

Тот же запрос, но другим способом:
$user = User::firstWhere('is_active', true);

Найти первый результат, а если не найден - то сделать определенные действия
$model = User::where('name', '=', 'Daniil Boyko')->firstOr(function() {
    echo 'Ok, ok, here we go again...';
});

Выбросить исключение при отсутствии результатов запроса:
$user = User::findOrFail(1);
$user = User::where('name', '=', 'Daniil Boyko')->firstOrFail();

Если исключение не перехвачено, то клиенту автоматически отправляется HTTP-ответ 404:
Route::get('/api/flights/{id}', function ($id) {
    return Flight::findOrFail($id);
});

Получить рейс по `name` или создать его, если его не существует:
$flight = Flight::firstOrCreate([
    'name' => 'London to Paris'
]);

Получить рейс по `name` или создать его с атрибутами `name`,` delayed` и `arrival_time`:
$flight = Flight::firstOrCreate(
    ['name' => 'London to Paris'],
    ['delayed' => 1, 'arrival_time' => '11:30']
);

Получить рейс по `name` или создать новый экземпляр Flight:
$flight = Flight::firstOrNew([
    'name' => 'London to Paris'
]);

Получить рейс по `name` или создать экземпляр с атрибутами `name`, `delayed` и `arrival_time`:
$flight = Flight::firstOrNew(
    ['name' => 'Tokyo to Sydney'],
    ['delayed' => 1, 'arrival_time' => '11:30']
);

-----------------------------------------------------------------------------------------------------------
Извлечение агрегатов
-----------------------------------------------------------------------------------------------------------
Количество записей по условию:
$count = Flight::where('active', 1)->count();

Максимальное значение по условию:
$max = Flight::where('active', 1)->max('price');

Другие агрегатные функции:
https://laravel.su/docs/8.x/queries#aggregates

-----------------------------------------------------------------------------------------------------------
Создание моделей
-----------------------------------------------------------------------------------------------------------
Мы возвращаемся к контроллерам, потому что писать в рутах в callback функции какую-то логику - это кринж.
class UserController
{
    public function store()
    {
        $user = new User();
            Можно так
        $user->name = $request->name;
            А можно так
        $user->name = $request->input('name');

        $user->save();
        Когда мы сейвим эту запись, поля created_at и update_at будут заполнены автоматически
    }
}

Также создавать модели можно и другим способом:
$user = User::create([
    'name' => 'Daniil Boyko',
]);
Но тогда перед использованием метода create нужно указать в классе модели такие свойства как fillable и guarded.
 * Поля которые могут быть заполнены вручную.
    protected $fillable = [
        'name',
        'email',
        'password',
    ];

 * Поля которые защищены от ручной вставки.
    protected $hidden = [
        'password',
        'remember_token',
    ];

Мы также можем добавить 2 условия в where, когда ищем записи:
$user = User::where('is_active', true)
    ->where('name', '=', 'Daniil Boyko')
    ->update(['is_admin' => true]);
Метод update ожидает массив пар ключей и значений, представляющих столбцы, которые должны быть обновлены.

-----------------------------------------------------------------------------------------------------------
Грязные/чистые модели
-----------------------------------------------------------------------------------------------------------
Метод isDirty определяет была ли изменена модель в текущем состоянии.
isClean делает точно наоборот.
Оба этих методов можно применять не ко всей модели в целом, а только к полю.
    $user = User::create([
        'first_name' => 'Taylor',
        'last_name' => 'Otwell',
        'title' => 'Developer',
    ]);

    $user->title = 'Painter';

    $user->isDirty(); // true
    $user->isDirty('title'); // true
    $user->isDirty('first_name'); // false

    $user->isClean(); // false
    $user->isClean('title'); // false
    $user->isClean('first_name'); // true

    $user->save();

    $user->isDirty(); // false
    $user->isClean(); // true

По названию метода wasChanged наверно понятно, какой результат она выдаст и при каком условии.
Вот пример кода:
    $user = User::create([
        'first_name' => 'Taylor',
        'last_name' => 'Otwell',
        'title' => 'Developer',
    ]);

    $user->title = 'Painter';

    $user->save();

    $user->wasChanged(); // true
    $user->wasChanged('title'); // true
    $user->wasChanged('first_name'); // false

По названию метода getOriginal должно быть понятно, что происходит:
Вот пример кода:
    $user = User::find(1);

    $user->name; // Daniil
    $user->email; // email@example.com

    $user->name = "Jack";
    $user->name; // Jack

    $user->getOriginal('name'); // Daniil
    $user->getOriginal(); // Массив исходных атрибутов ...

Метод обновления-вставки:
В приведенном ниже примере, если существует рейс с пунктом отправления «Oakland» и пунктом назначения «San-Diego»,
его столбцы price и discounted будут обновлены. Если такой рейс не существует, то будет создан новый рейс с атрибутами,
полученными в результате слияния первого массива аргументов со вторым массивом аргументов.
    $flight = Flight::updateOrCreate(
        ['departure' => 'Oakland', 'destination' => 'San Diego'],
        ['price' => 99, 'discounted' => 1]
    );

Тут уже пошло совсем извращенство:
Если вы хотите выполнить несколько «обновлений-вставок» в одном запросе, вам следует использовать вместо этого метод upsert.
Первый аргумент метода состоит из значений для вставки или обновления, а второй аргумент перечисляет столбцы,
которые однозначно идентифицируют записи в связанной таблице.
Третий и последний аргументы метода – это массив столбцов, которые следует обновить, если соответствующая запись уже существует в БД.
Метод upsert автоматически устанавливает временные метки created_at и updated_at, если они разрешены в модели:
    Flight::upsert([
        ['departure' => 'Oakland', 'destination' => 'San Diego', 'price' => 99],
        ['departure' => 'Chicago', 'destination' => 'New York', 'price' => 150]
    ], ['departure', 'destination'], ['price']);

-----------------------------------------------------------------------------------------------------------
Удаление моделей
-----------------------------------------------------------------------------------------------------------
Удаление модели, тут нехуй добавить, нехуй убавить
    $user = User::find(1);
    $user->delete();

Можно удалить все модели
    User::truncate();

Удаление модели по ID:
    Flight::destroy(1);
    Flight::destroy(1, 2, 3);
    Flight::destroy([1, 2, 3]);
    Flight::destroy(collect([1, 2, 3]));

Удаление по условию:
    $deletedRows = Flight::where('active', 0)->delete();

Теперь о том, что такое softDelete;
Надо написать миграцию в табличку со строкой
    Schema::table('flights', function (Blueprint $table) {
        $table->softDeletes();
    });
    и в классе модели написать use SoftDeletes;

Это добавляет колонку deleted_at.
Теперь если вы будете удалять какую-то строку из таблички, по сути она удаляться не будет, но в поле deleted_at появится timestamp удаления.
Соответственно если мы в дальнейшем будем писать select на табличку - эти записи не будут показываться в результате запроса.
Чтобы восстановить какую-то softDelete запись, то указываем:
    $user->restore()
Либо
    App\Models\Flight::withTrashed()
        ->where('airline_id', 1)
        ->restore();

Чтобы полностью удалить запись из таблички, которая имеет softDelete, указываем:
    $user->forceDelete();

Метод onlyTrashed покажет только программно удаленные записи:
    $flights = Flight::onlyTrashed()
        ->where('airline_id', 1)
        ->get();
