# Laravel Framework Documentation
was made according to self-improvement spreadsheet

Рекомендую курсы:
Max Orlov - Laravel
Cutcode - Laravel

Routes - 10 row
Controllers - 202 row
Middlewares - 290 row
Views - 404 row

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                                  Routes
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Руты это не рут права на андроиде при взламывании игр. © Daniil Boyko

Пример route с callback функцией:
    Route::get('/hello', function() {
        return 'Hello World';
    });
Следовательно, после перехода в браузере на url: 127.0.0.1:8000/hello - мы увидим надпись Hello World.

По умолчанию все routes находятся в файле routes/web.php
Мы можем зарегистрировать новый файл в RouteServiceProvider.php
    Route::middleware('web')
        ->group(function() {
            require base_path('routes/web.php');
            require base_path('routes/admin.php');
            require base_path('routes/user.php');
        });
О страшном слове middleware позже.

-----------------------------------------------------------------------------------------------------------
Routes types:
    Route::get('url', 'function');
    Route::post('url', 'function');
    Route::put('url', 'function');
    Route::patch('url', 'function');
    Route::delete('url', 'function');
    Route::options('url', 'function');
-----------------------------------------------------------------------------------------------------------
GET метод позволяет получить все то, что нельзя никак отредактировать, добавить, удалить и так далее (к примеру HTML странички)
POST - может использоваться также для редактирования ресурса
PUT - для редактирования ресурса
DELETE - удаление ресурса
OPTIONS - представляет запрос информации об опциях соединения, доступных в цепочке запросов/ответов (короче конфиг)

Вроде с помощью POST можно редактировать какую-то запись и с помощью PUT, так в чем же разница?
    Представь, что у нас есть сервис с блогом и постами. В одном блоге может быть несколько постов.
    Для добавления нового поста мы конечно используем метод POST с url например: domain.com/blogs/id
    После создания нового поста метод POST сам создаст URL и вернет этот URL для доступа к нему через GET или для удаления через DELETE

    А теперь допустим, что такой пост уже создан и клиент хочет просто отредактировать его (исправить синтаксическую ошибку например)
    То есть другими словами, клиент хочет ПЕРЕЗАПИСАТЬ пост
    Для этого будет использован метод PUT с URL: domain.com/blogs/id/posts/post_id, он передает обновленную запись в теле запроса
    Сервис, ориентируясь на метод PUT удаляет старую запись и перезаписывает новую, при этом этот пост доступен по тому же URL

    Нет конкретного правила на использования POST и PUT, но все же стоит придерживаться рекомендаций в целях единообразной трактовки
    методов всеми разработчиками

    Смотрел форум по презентации LARAVEL 9, там говорилось о том, что рекомендуется использовать POST для создания подчиненного ресурса
    (все на том же примере: в блоге много постов, значит посты - подчиненный ресурс)

PATCH используется для частичного изменения ресурса. PUT создает новый ресурс или заменяет представление целевого ресурса, данными представленными в теле запроса.
Другими словами, PATCH вложенный объект содержит набор инструкций, описывающих, как ресурс,
находящийся в данный момент на исходном сервере, должен быть модифицирован для создания новой версии.
А в PUT содержится новая версия ресурса целиком.

Если мы хотим зарегистрировать сразу несколько методов, можем использовать match:
    Route::match(['get', 'post'],  'url', 'function');

Если мы хотим зарегистрировать сразу все методы по руту:
    Route::any('url', 'function')

Любые HTML формы, указывающие на маршруты POST, PUT, PATCH, DELETE - должны быть защищены системой csrf
Для этого в HTML форме достаточно указать '@csrf' сразу после объявления формы

Если мы хотим перенаправить пользователя с одного url на другой - используем redirect:
    Route::redirect('current_url', 'new_url');
По умолчанию возвращается код 302, но его можно переопределить:
    Route::redirect('current_url', 'new_url', 301);
Если нужно вернуть только код состояния, используем permanentRedirect:
    Route::permanentRedirect('current_url', 'new_url');

В дальнейшем слова 'HTML шаблон' я буду заменить на 'вьюха'
Если мы хотим вернуть по определенному url вьюху, то используем view:
    Route::view('url', 'name_of_the_view');
Если нужно передать какие-то параметры во вьюхе, используем:
    Route::view('url', 'name_of_the_view', ['name_of_the_value' => 'value']);

Если нам нужно указывать в url какой-либо параметры типа ID пользователя или номер блога, используем:
    Route::get('url/{value}', function($value) {
        return 'User: ' . $value;
    });

Можно передавать сразу несколько параметров:
    Route::get('url/{some_value}/comments/{some_another_value}', function($some_value, $some_another_value) {
        return 'User: ' . $value . ' Post: ' . $some_another_value;
    });

Если параметр не всегда должен/может присутствовать в маршруте, используем '?':
    Route::get('/url/{value?}' , function($value = null) {
        return $value;
    });
    Route::get('/url/{value?}' , function($value = 'value') {
        return $value;
    });

Можно передать какие-то ограничения по регулярному выражению с помощью '->where()':
    Route::get('/url/{value}', function ($value) {
        // some code
    })->where('value', '[A-Za-z]+');
    Route::get('/url/{value}', function ($value) {
        // some code
    })->where('value', '[0-9]+');
    Route::get('/url/{id}/{value}', function ($value) {
        // some code
    })->where([
        'id' => '[0-9]+'
        'value' => '[0-9]+'
        ]);

Также есть шаблонные правила типа whereNumber, whereAlpha, whereAlphaNumeric:
    Route::get('/url/{id}', function($id) {
        // some code
    })->whereNumber('id');
Если входные значения не пройдут валидацию - будет возвращена 404 ошибка

-----------------------------------------------------------------------------------------------------------
Префиксы для URL
-----------------------------------------------------------------------------------------------------------
Мы можем добавить префикс для группы маршрутов, используем:
Route::prefix('name_of_the_prefix')->group(function() {
    Route::
    Route::
    Route::
});
Тогда мы сможем получить доступ к этим маршрутов по URL:
domain.com/name_of_the_prefix/url

-----------------------------------------------------------------------------------------------------------
Префиксы для ROUTES
-----------------------------------------------------------------------------------------------------------
Мы можем добавить префикс для имен маршрутов, используем:
Route::name('name_of_the_prefix.')->group(function() {
    Route:: -> name('some_name_1');
    Route:: -> name('some_name_2');
    Route:: -> name('some_name_3');
});
Тогда мы сможем получить доступ к этим маршрутам:
    route('name_of_the_prefix.name_of_the_route');

-----------------------------------------------------------------------------------------------------------
Глобальные ограничения
-----------------------------------------------------------------------------------------------------------
Можно поставить определенные ограничения по всем routes в файле RouteServiceProvider в методе boot():
    public function boot()
    {
        Route::pattern('id', '[0-9]+');
    }

-----------------------------------------------------------------------------------------------------------
Именование маршрутов
-----------------------------------------------------------------------------------------------------------
Имена маршрутов всегда должны быть уникальными

Чтобы иметь доступ к маршрутам во views, controller, jobs, commands, events, observers, action-classes, models
(обо всех этих матерных словах позже), можно задать имя маршруту
    Route::get('/url', 'function')->name('name');

Чтобы перенаправить на какой-то route, можем использовать только имя маршрута:
    return redirect()->route('profile');

Можно передать параметры в маршрут, используя имя маршрута:
    Route::get('/url/{id}', function($id) {
        // some logic
    })->name('some_name');

    $url = route('some_name', ['id' => 1]);

Можно передать еще параметры, даже если их нет в самом маршруте, тогда они будут добавлены в url таким образом:
    Route::get('/user/{id}/profile', function ($id) {
        //
    })->name('profile');

    $url = route('profile', ['id' => 1, 'photos' => 'yes']);
    // /user/1/profile?photos=yes

-----------------------------------------------------------------------------------------------------------
Кэширование маршрутов
-----------------------------------------------------------------------------------------------------------
Использования кэша маршрутов гораздо сократит загрузку той или иной страницы.
Чтобы сгенерировать кэш маршрута:
    php artisan route:cache

Но после изменения routes (добавление нового рута, удаление или изменение рута),
кэш нужно обновить. Чтобы перезаписать cache используем всю ту же команду:
    php artisan route:cache

Чтобы очистить кэш маршрутов:
    php artisan route:clear

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                                Controllers
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Контролируем маршруты контроллерами. © Daniil Boyko

Готовьтесь к тому, что вы будете переносить свою логику из callback функций в рутах, в контроллеры,
а потом из controllers в events, из events в observers, из observers в jobs, а потом из jobs в action классы, потому что так - ОПТИМИЗИРОВАННЕЕ! syka...
Обо всех страшных словах потом, пока ты не готов.
На моей личной практике я рефакторил весь проект уже 5 раз, по мере изучения Laravel.

-----------------------------------------------------------------------------------------------------------
Создание контроллера
-----------------------------------------------------------------------------------------------------------
Чтобы создать контроллер, используем:
    php artisan make:controller <NameController>
Хранятся они в каталоге app/Http/Controllers
По рекомендациям разработчиков laravel лучше создавать контроллеры со словом "Controller" в конце названия
UserController, AdminController

-----------------------------------------------------------------------------------------------------------
Базовые понятия
-----------------------------------------------------------------------------------------------------------
В контроллерах мы можем писать методы, которые будут исполняться, когда пользователь будет переходить по какому-то route.
Посмотрите файл RegisterController.php

Чтобы определить метод, который будет исполняться при переходе по руту, в самом объявлении рута пишем:
    Route::get('/url', [ControllerClass::class, 'name_of_the_method'])->name('some_name');

Т.е. когда входящий запрос будет совпадать с указанном URL, будет вызван метод 'name_of_the_method' контроллера 'ControllerClass',
также параметры маршрута будут переданы методу
Пример route с параметрами
    Route::get('/url/{id}', [Controller::class, 'name_of_the_method'])->name('some_name');

Тогда в методе в классе контроллера будем передавать этот 'id'
    public function name_of_the_method($id)
    {
        return $id;
    }

-----------------------------------------------------------------------------------------------------------
Контроллеры одиночного действия
-----------------------------------------------------------------------------------------------------------
Контроллеры одиночного действия - это контроллеры, в которых есть только 1 магический метод - __invoke
Помним из ООП, __invoke - magic method. Он будет исполнен, если не будет найден ни один подходящий метод
Тогда как зарегистрировать этот метод в route? Очень просто, его вообще указывать не нужно
    Route::post('/url', ControllerClass:: class)->name('some_name');

Чтобы сразу сгенерировать контроллер одиночного действия, нужно просто написать:
    php artisan make:controller NameController --invokable

-----------------------------------------------------------------------------------------------------------
Ресурсные контроллеры
-----------------------------------------------------------------------------------------------------------
Ресурсный контроллер - это контроллер, у которого есть все основные методы, отвечающие на GET, PUT, POST.. запросы
Чтобы создать такой контроллер, используем:
    php artisan make:controller NameController --resource

Можно зарегистрировать ресурсный route, используя:
    Route::resource('/url', NameController::class);

Пока не напишешь говно-код, не поймешь что такое говно-код. © Daniil Boyko
К чему я это? А к тому, что можно и объявлять несколько ресурсных контроллеров сразу
    Route::resources([
        '/photos' => PhotoController::class,
        '/posts' => PostController::class,
    ]);
Но это bad pattern, никогда так не делайте, иначе при удалении какого-либо из методов в одном из этих контроллеров,
придется вытягивать это из массива, переписывать руты

Действия, выполняемые ресурсными контроллерами
Метод	        URI	               Действие	        Имя маршрута
GET	        /photos	                index	        photos.index
GET	        /photos/create	        create	        photos.create
POST	    /photos	                store	        photos.store
GET	        /photos/{photo}	        show	        photos.show
GET	        /photos/{photo}/edit	edit	        photos.edit
PUT/PATCH	/photos/{photo}	        update	        photos.update
DELETE	    /photos/{photo}	        destroy	        photos.destroy

Никто не ограничивает вас в том, чтобы добавить новые методы в ресурсный или какой-либо другой контроллер
Точно также
1) Добавляем метод в контроллер, пишем логику в методе
2) Добавляем его в рутах и все

Там дальше идет взаимодействие с service container и eloquent моделями, но пока, как я понимаю,
это темный лес, поэтому пока закончу на этом свой рассказ

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                                Middlewares
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Волк не тот, кто работает с данными. Волк тот, кто работает с данными. © Daniil Boyko

Переходим к страшному слову middleware

-----------------------------------------------------------------------------------------------------------
Базовые понятия
-----------------------------------------------------------------------------------------------------------
По-быстрому что это и зачем нужно:
Мы хотим перейти на какой-то рут, чтобы увидеть вьюху или отправить какие-то данные в форме (например, зарегистрироваться)
Наверняка слышали о MVC - Model View Controller

Для себя я объяснил это так:
    У нас есть три этапа жизни запроса
    1) Отправка самого запроса
    2) Валидация данных
    3) Получение результата в контроллере
Вот то, что делает middleware - находится между 1 и 2 пунктом. По-русски middleware - посредник.
Сейчас легкое объяснение, по которому поймете. Например, middleware 'auth'
Он проверяет авторизирован ли пользователь в нашем приложении, если ответ положительный - он перенаправляет запрос в контроллер.
Надеюсь понятно, что это чистый приспособленец валидации

-----------------------------------------------------------------------------------------------------------
Создание middleware
-----------------------------------------------------------------------------------------------------------
Чтобы создать middleware, используем:
php artisan make:middleware NameMiddleware
Опять же, в конце названия middleware (посредника) - надо писать слово Middleware, чтобы в первую очередь вам было легче потом искать конкретный файл
Но просто создать middleware и написать там логику - мало, надо его еще зарегистрировать.
Где регистрировать?
    Ответ: в app/Http/Kernel.php

Коротко о том, что находится в этом файле:
В свойстве $routeMiddleware содержатся уже зарегистрированные Laravel middlewares, которые идут из коробки.
Можем добавить туда свой middleware:
    'alias' => NameMiddleware::class,

-----------------------------------------------------------------------------------------------------------
Использование middleware
-----------------------------------------------------------------------------------------------------------
Написали логику в посреднике, зарегистрировали его, а как применять? Вот так:
    Route::get('/url', function() {
        // some code
    }->middleware('alias');

Если вам одного посредника мало, вы абьюзер и хотите еще больше ограничить права людей, то вот как применять сразу несколько посредников на один маршрут:
    Route::get('/url', function() {
        // some code
    }->middleware(['alias_1', 'alias_2']);

Но можно и не указывать алиасы, а просто передать instance:
    Route::get('/url', function() {
         // some code
    }->middleware(NameMiddleware::class);

Помните в разделе про руты, можно было группировать маршруты, так вот можно и применять middleware сразу на всю группу маршрутов:
    Route::prefix('name_of_the_prefix')->group(function() {
        Route::middleware([NameMiddleware::class])->group(function() {
            Route:: ;
            Route:: ;
            Route:: ;
        });
    });

Не хотите так? Можно и так:
    Route::prefix('name_of_the_prefix')->group(function() {
        Route::group(['middleware' => NameMiddleware::class], function() {
            Route:: ;
            Route:: ;
            Route:: ;
        });
    });

Может быть такая ситуация, когда какой-то маршрут из группы не вынесешь, потому что будет не очень красиво,
тогда можно исключить middleware для этого рута:
    Route::prefix('name_of_the_prefix')->group(function() {
        Route::group(['middleware' => NameMiddleware::class], function() {
            Route:: ;
            Route:: ;
            Route::get('/url', function() {
                // some code here
            })->withoutMiddleware([NameMiddleware::class]);
        });
    });

-----------------------------------------------------------------------------------------------------------
Группы of middlewares
-----------------------------------------------------------------------------------------------------------
Пойдем дальше по файлу Kernel.php - его кстати называют HTTP ядром приложения
    Свойство $middlewareGroups. Зачем нужно? У нас ведь есть alias для какого-то конкретного посредника (в свойстве $routeMiddleware),
    так вот можно назначить несколько посредников сразу под один alias. Надеюсь, догадаетесь как добавлять -_-

    Ну тогда и применять эти middlewares будем по одному alias:
        Route::get('/url', function () {
            // some code here
        })->middleware('alias');
    Ну или так, никакой разницы:
        Route::middleware(['alias'])->group(function() {
            Route::get('/url', function () {
                // some code here
            }
        }

-----------------------------------------------------------------------------------------------------------
Приоритетность посредников
-----------------------------------------------------------------------------------------------------------
Далее есть предопределенное свойство $middlewarePriority. Зайди и посмотри, что там перечислено.

Гы. Его там нет, иди сюда обратно. Ну и куда ты пошел смотреть его?
Это свойство нужно объявить, если тебе важен порядок выполнения middleware. На моей практике не требовалось этого.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                                Views
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Только дед инсайды возвращают в callback функциях HTML-код. © Daniil Boyko

-----------------------------------------------------------------------------------------------------------
Базовые понятия
-----------------------------------------------------------------------------------------------------------
Все шаблонные представления (далее вьюхи) располагаются в каталоге resources/views/
Чтобы вьюха была доступна по руту, для начала как бы ее надо создать.
Про то, почему шаблонизатор '.blade.php' лучше простого HTML - потом.
После создания, вьюху можно получить так:
    Route::get('/url', function() {
        return view('name_of_the_view');
    });

Либо можно использовать фасад View:
    Route::get('/url', function() {
        return View::make('name_of_the_view');
    });

Чтобы передать какой-то параметр во вьюху, используем:
    Route::get('/url/', function() {
        return view('name_of_the_view', ['name' => 'Danya']);
    });
    И в самой вьюхе тогда:
    <html>
        <body>
            <h1>Привет, {{ $name }}</h1>
        </body>
    </html>

-----------------------------------------------------------------------------------------------------------
Получение вьюхи из поддиректорий
-----------------------------------------------------------------------------------------------------------
Рассмотрим кейс, если у нас есть поддиректория в каталоге views. Например /resources/views/admin/index.blade.php
Тогда возврат вьюхи будет выглядеть так:
    Route::get('/url', function() {
        return view('admin.index');
    });

Честно, следующий кейс не знаю когда может применяться, но запихну его сюда.
    Route::get('/url', function() {
        if (View::exists('name_of_the_view')) {
            return view('name_of_the_view');
        } else {
            abort(403);
        }
    });
Это типо если вы не знаете есть вьюха или нет, но понятия не имею как разработчик может не знать какие вьюхи есть в проекте, а какие нет.
В sxope-ocean нет ни одного такого примера.

Есть еще способ как передать данные во вьюху:
    Route::get('/url', function() {
        return view('admin.index')
            ->with('name', 'Danya')
            ->with('surname', 'Boyko');
    });

-----------------------------------------------------------------------------------------------------------
Передача данных из контроллера во вьюху
-----------------------------------------------------------------------------------------------------------
1) Объявили рут:
    Route::get('/test-data-to-view', [UserController::class, 'testDataToView'])->name('test-data-to-view');

2) Написали метод в контроллере. Вот, то как правильнее передавать данные во вьюху. Не знаю почему, но ->with у меня не всегда работает. С чем связано - не знаю.
    public function testDataToView()
    {
        $id = 123123123;
        return view('views-tester', compact('id'));
    }
3) Вывели это в /resources/views/views-tester.blade.php
    {{ $id }}

-----------------------------------------------------------------------------------------------------------
Шаринг данных на все вьюхи
-----------------------------------------------------------------------------------------------------------
Бывают такие кейсы, когда данные должны передаваться во все вьюхи сразу, а если таких вьюх тысяча, то что делать?
Правильно, зарегистрировать эти переменные и значения в AppServiceProvider.php в методе 'boot'. Ага, так ты и ответил, конечно.
    public function boot()
    {
        View::share('key', 'value');
    }

-----------------------------------------------------------------------------------------------------------
Кэширование вьюх
-----------------------------------------------------------------------------------------------------------
Честно, это заеб. Ничего больше не могу сказать. Кэшировать то легко, но точно как в случае с рутами:
При каждом изменении во вьюхе, нужно будет переопределять кэш, чтобы увидеть окончательный результат.
Считаю, что кэширование нужно на каких-то крупных сервисах, потому что это оптимизация, на localhost это ни к чему.
Но все же, чтобы закэшировать вьюхи, используем:
    php artisan view:cache

Очистить кэш вьюх:
    php artisan view:clear

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                                Models
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Laravel модель это не Kylie Jenner, но поебаться с этим стоит. © Daniil Boyko

-----------------------------------------------------------------------------------------------------------
Базовые понятия
-----------------------------------------------------------------------------------------------------------
Laravel содержит ORM-библиотеку Eloquent. Все дружно поняли, что такое ORM-библиотеку, ага, конечно.
ORM - Object Relational Mapping, это библиотека, которая позволяет взаимодействовать с базой данных в рамках концептах ООП.
Также это может означать Object Role Model. При использовании Eloquent каждая таблица БД имеет Модель, которая используется
для взаимодействия с таблицей.
Создайте базу mysql, вот мои конфиг в .env:
    DB_CONNECTION=mysql
    DB_HOST=127.0.0.1
    DB_PORT=3306
    DB_DATABASE=laravel
    DB_USERNAME=root
    DB_PASSWORD=

-----------------------------------------------------------------------------------------------------------
Создание моделей
-----------------------------------------------------------------------------------------------------------
Чтобы создать модель, используем:
    php artisan make:model Post
Чтобы создать модель сразу с миграцией:
    php artisan make:model Post --migration
    php artisan make:model Post -m
Можно комбинировать флаги, например:
    php artisan make:model Post -mfsc - Это создает модель, миграцию, фабрику, сид, контроллер
О том, что такое фабрика и сид - позже.
Созданные модели находятся в app\Models.

-----------------------------------------------------------------------------------------------------------
Соглашение по именованию моделей
-----------------------------------------------------------------------------------------------------------
По умолчанию при создании модели Post, Laravel подразумевает, что эта модель будет связана с таблицей posts в базе данных
Тоже самое: модель User - табличка users

-----------------------------------------------------------------------------------------------------------
Конфигурация моделей
-----------------------------------------------------------------------------------------------------------
Бывают такие кейсы, в которых нужно другое название таблицы, например:
    Модель Post - таблица history_posts;
Тогда в классе модели можно просто указать protected свойство $table = 'history_posts';

Предполагается из коробки, что первичным ключом в каждой таблицы будет 'id', но если он у нас другой, то в классе модели:
    protected $primaryKey = 'another_name_of_primary_key';

Laravel также предполагает, что primary key является auto-incrementing (т.е. увеличивающимся автоматически на 1) integer.
Но если, например, у нас есть табличка currencies (валюты), то удобнее держать primary key в виде названия валюты, т.е string.
Тогда в модели указываем:
    public $incrementing = false;
    protected $keyType = 'string';

Составные первичные ключи не поддерживаются Eloquent, но можно создать дополнительные уникальные индексы к таблицам БД

В каждой табличке Laravel автоматически определит две колонки: created_at, updated_at. Если не хотим их видеть:
    public $timestamps = false;

Если мы хотим поменять формат даты в колонках:
    protected $dateFormat = 'U';

Если мы хотим изменить начальные имена created_at, updated_at колонок, то в классе модели:
    CONST CREATED_AT = 'creation_date';
    CONST UPDATED_AT = 'updated_date';

Если хотим указать не дефолтное значение в подключении к БД, то:
    protected $connection = 'another_connection';

Если хотим указать стандартное значение для определенных полей, то:
    protected $attributes = [
        'name' => 'Danya';
    ];


-----------------------------------------------------------------------------------------------------------
Eloquent query builder
-----------------------------------------------------------------------------------------------------------
Чтобы получить все записи таблички, связанной с моделью:
    $users = User::all();
    foreach($users as $user) {
        echo $user->name;
    }

Также можно получать записи с дополнительными условиями:
    $users = User::where('name', '=', 'John')
        ->orderBy('id')
        ->take(10)
        ->get();
Здесь
   WHERE - аналог WHERE в sql
   TAKE - аналог LIMIT
   GET - получение результатов

Метод refresh повторно обновит модель, используя свежие данные из БД:
    $flight = Flight::where('number', 'FR 900')->first();
    $flight->number = 'FR 456';
    $flight->refresh();
    $flight->number; // "FR 900"

Методы all и get возвращают не массив, а экземпляр класса Collection, который содержит много полезных методов.

