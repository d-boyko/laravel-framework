### Service Container
Контейнер служб - мощный инструмент управления зависимостями классов и выполнения внедрения зависимостей.
Если коротко и без воды - когда мы передаем в какой-то метод переменную класса, то под капотом автоматически создается
экземпляр класса.

```php
class UserController extends Controller
{
    protected $users;

    public function __construct(UserRepository $users)
    {
        $this->users = $users;
    }

    /**
    *   Показать профиль конкретного пользователя
    */
    public function show($id)
    {
        $user = $this->users->find($id);
        return view('user.profile', ['user' => $user];
    }
}
```
Если класс не имеет зависимостей или зависит только от других конкретных классов (не интерфейсов),
контейнер не нужно инструктировать о том, как создавать этот класс.
Допустим есть какой-то класс Service:
```php
class Service
{
    //
}
```

Тогда, например, в routes/web.php:
```php
Route::get('/', function(Service $service) {
    die(get_class($service));
});
```

В этом примере при посещении '/' рута, маршрут автоматически получит экземпляр класса Service
и внедрит его в обработчике вашего маршрута.
Многие классы, которые мы используем в процессе разработки приложения Laravel получают свои зависимости через контейнер,
включая controllers, listeners, events, middlewares и так далее. Так можно указать зависимости в методе handle в job.
О том, что такое listeners, events, jobs чуть позже. Как только потренируетесь с автоматическим
не конфигурируемым внедрением зависимостей, ты почувствуешь невозможность разработки без нее.

### Service Provider
Это центральное место начальной загрузки всех приложений Laravel.
Что подразумевается под начальной загрузкой? Это регистрация элементов, включая регистрацию связываний контейнера служб,
слушателей (listeners), событий (events), посредников (middleware), маршрутов (routes).
Сервис-провайдеры - центральное место для конфигурирования приложения.

В файле config/app.php, мы увидим массив $providers. Это все классы сервис-провайдеров, которые будут загружены вашим приложением.
Они загружают основные компоненты Laravel, такие как подсистема отправки почты, очередь, кэш и другие.
Многие из них являются "отложенными", это значит что они не будут загружаться при каждом запросе, а только так,
когда предоставляемые ими службы действительно необходимы.
По умолчанию там основные сервис-провайдеры, но никто не запрещал добавлять свои.

Структура service provider.
Почти в каждом сервис-провайдере есть всего два методы: register и boot.
В рамках метода register следует только связывать (биндить) сущности в контейнере служб.
Никогда не следует пытаться зарегистрировать каких-либо слушателей событий, маршруты или что-то другое в методе register.
В противном случае вы можете случайно воспользоваться подсистемой, чей сервис-провайдер еще не загружен.

Как сгенерировать новый сервис-провайдер?
```shell
  php artisan make:provider RiskServiceProvider
```

Напишем что-то в методе register, и я не говорю про фразу "акуленок ту руруру".
В любом из методов сервис-провайдера у вас есть доступ к свойству $app, которое обеспечивает доступ к контейнеру служб:
```php
class RiskServiceProvider extends ServiceProvider
{
    /**
     * Регистрация любых служб приложения.
     *
     * @return void
     */
    public function register()
    {
        $this->app->singleton(Connection::class, function ($app) {
            return new Connection(config('riak'));
        });
    }
}
```
Если ваш сервис-провайдер регистрирует много простых связываний,
вы можете использовать свойства bindings и singletons вместо ручной регистрации каждого связывания контейнера.
Когда сервис-провайдер загружается фреймворком, он автоматически проверяет эти свойства и регистрирует их связывания:
```php
class AppServiceProvider extends ServiceProvider
{
    /**
     * Все связывания контейнера, которые должны быть зарегистрированы.
     *
     * @var array
     */
    public $bindings = [
        ServerProvider::class => DigitalOceanServerProvider::class,
    ];

    /**
     * Все singleton контейнера, которые должны быть зарегистрированы.
     *
     * @var array
     */
    public $singletons = [
        DowntimeNotifier::class => PingdomDowntimeNotifier::class,
        ServerProvider::class => ServerToolsProvider::class,
    ];
}
```

Теперь поговорим про метод boot.
Это метод вызывается после регистрации всех остальных сервис-провайдеров, что означает,
что в этом месте у вас уже есть доступ ко всем другим службам, которые были зарегистрированы фреймворком.
```php
class ComposerServiceProvider extends ServiceProvider
{
    /**
    * Загрузка любых служб приложения.
    *
    * @return void
    */
    public function boot()
    {
        View::composer('view', function () {
            //
        });
    }
}
```
### Когда использовать контейнер?
При валидации, например, данных из формы - мы передаем в метод контроллера параметр Request $request.
Это уже внедрение зависимости. Но в данном случае мы не трогаем контейнер.
Во-первых, если вы пишете класс, реализующий интерфейс,
и хотите объявить тип этого интерфейса в конструкторе маршрута или класса, то вы должны сообщить контейнеру,
как получить этот интерфейс.
Во-вторых, если вы пишете пакет Laravel,
которым планируете поделиться с другими разработчиками Laravel,
вам может потребоваться связать службы вашего пакета в контейнере.

### Отложенные провайдеры
Если ваш сервис-провайдер регистрирует только связывания в контейнере служб, вы можете отложить его регистрацию до тех пор,
пока одно из зарегистрированных связываний не понадобится. Отсрочка загрузки повысит производительность приложения,
так как он не загружается из файловой системы при каждом запросе.
Laravel загрузит отложенный сервис-провайдер только при необходимости одной из этих служб.

Чтобы отложить загрузку сервис-провайдера, надо реализовать интерфейс DefferableProvider, описав метод provides.
Метод provides должен вернуть связывания контейнера службы, регистрируемые данным классом:
```php
class RiakServiceProvider extends ServiceProvider implements DeferrableProvider
{
    /**
    * Регистрация любых служб приложения.
    *
    * @return void
    */
    public function register()
    {
        $this->app->singleton(Connection::class, function ($app) {
            return new Connection($app['config']['riak']);
        });
    }

    /**
     * Получить службы, предоставляемые поставщиком.
     *
     * @return array
     */
    public function provides()
    {
        return [Connection::class];
    }
}
```
