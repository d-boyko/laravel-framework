### Cache

Некоторые задачи по извлечению или обработке данных, выполняемые вашим приложением,
могут потребовать больших ресурсов ЦП или занять несколько секунд.
В этом случае извлеченные данные обычно кешируют на некоторое время,
чтобы их можно было быстро извлечь при последующих запросах тех же данных.

Файл конфигурации находится по адресу config/cache.php. Там можно указать какой драйвер кэша.
Laravel из коробки поддерживает Redis, Memcached, DynamoDB и реляционные базы данных.

По умолчанию Laravel настроен на использование драйвера кеширования файлов, который хранит сериализованные кешированные объекты
в файловой системе сервера. Для более крупных приложений рекомендуется использовать более надежный драйвер,
например Memcached или Redis.

Есть такой фасад Cache, с помощью которого можно взаимодействовать с технологий кэширования.
Тут больше подойдет документация в рамках "вопрос - ответ".

Как обратиться к хранилищу кэша? >
```php
Cache::store('type')->get('key');
Cache::store('file')->get('foo');
Cache::store('redis')->get('bar');
```

Как получить элемент кэша?
```php
Cache::get('key');
```
^ Можно передать дефолтное значение вторым аргумент ('key', 'default');

```php
Cache::get('key', function() {
    return DB::table(<query>)->get();
});
```
^ Можно передать функцию замыкания в качестве дефолтного значения.

Как проверить наличие кэша по ключу?
```php
if (Cache::has('key')) {
}
```

Как увеличить или уменьшить отдельные значения в кэше?
```php
Cache::increment('key');
Cache::decrement('key');
```
^ Можно указать величие увеличения или уменьшения значения элемента ('key', $amount);

Как выполнить замыкание с сохранением и получением результата?
```php
$value = Cache::remember('users', $seconds, function() {
    return DB::table('users')->get();
});
```
^ Если элемент не существует в кэше, то будет выполнено замыкание и его результат будет помещен по ключу в кэш.

Как навсегда сохранить элемент к кэше?
```php
Cache::rememberForever('users', function() {
    return DB::table('users')->get();
});
```

Как получить данные и сразу уже удалить элемент?
```php
Cache::pull('key');
```

Как сохранить элемент в кэше?
```php
Cache::put('key', 'value', $seconds = 10);
```
^ Если третий аргумент не передается, то аргумент будет храниться бесконечно до момента его удаления.

Как еще можно передать время сохранения кэша?
```php
Cache::put('key', 'value', now()->addMinutes(30));
```

Как сохранить результат в кэше при условии их отсутствия?
```php
Cache::add('key', 'value', $time);
```

Как сохранить элемент на постоянное основе?
```php
Cache::forever('key', 'value');
```

Как просто удалить элемент кэша без его доставания достатия достания:
```php
Cache::forget('key');
```

Как удалить методы используя извращенство и БДСМ?
```php
Cache::put('key', 'value', 0);
Cache::put('key', 'value', -5);
```
^ Указать в качестве третьего аргумент отрицательное значение

Как очистить весь кэш?
```php
php artisan cache:clear
```
Либо:
```php
Cache::flush();
```

Рубрика "вопрос - ответ" закончена, еще пару моментов расскажу.
Есть фасад Cache, а есть helper cache();
Не, погнали опять по рубрике "вопрос - ответ".

Как извлечь значение кэша с помощью хелпера cache?:
```php
$value = cache('key');
```

Как записать данные в кэш и хранить определенное время?:
```php
cache(['key' => 'value'], $seconds);
cache(['key' => 'value'], now()->addMinutes(10));
```

Что будет если вызвать хелпер cache без аргументов?
Вы получите доступ к другим методам (они такие же как в фасаде Cache)
```php
cache()->remember('users', $seconds, function() {
    return DB::table('users')->get();
});
```

### Практическое применение в Sxope-Ocean
Помните когда мы запускаем джобу, и не дождавшись ее завершения запускаем еще раз? Какой там вывод?
```shell
staging.INFO: Caching bq-to-spanner for table members_statuses
[2022-09-02 15:25:45] staging.INFO: Job wasn't started. Caching bq-to-spanner for table members_statuses to value 2
```
Как сделать также? Очень просто

```php
$value = Cache::lock('key', 10);
if ($lock->get()) {
    $lock->release();
}
```

Как снять блокировку?
```php
$lock->release();
```

```php
Cache::lock('foo')->get(function () {
    // Блокировка установлена на неопределенный срок и автоматически снимается ...
});
```

Метод get также принимает замыкание. После выполнения замыкания Laravel автоматически снимет блокировку:
```php
Cache::lock('foo')->get(function () {
    // Блокировка установлена на неопределенный срок и автоматически снимается ...
});
```

Вот еще хороший фрагмент кода:
```php
$podcast = Podcast::find($id);
$lock = Cache::lock('processing', 120);
if ($lock->get()) {
    ProcessPodcast::dispatch($podcast, $lock->owner());
}
```
Иногда может потребоваться установить блокировку в одном процессе и снять ее в другом процессе.
Например, вы можете получить блокировку во время веб-запроса и захотите снять блокировку в конце задания в очереди,
которое запускается этим запросом. В этом сценарии вы должны передать «токен инициатора»
с областью действия блокировки в задании в очереди,
чтобы задание могло повторно создать экземпляр блокировки с использованием данного токена.

В приведенном ниже примере мы отправим задание в очередь, если блокировка будет успешно получена.
Кроме того, мы передадим токен инициатора блокировки заданию в очереди с помощью метода owner блокировки.

В рамках задания ProcessPodcast нашего приложения мы можем восстановить и снять блокировку с помощью токена инициатора:
```php
Cache::restoreLock('processing', $this->owner)->release();
```
Если вы хотите принудительно снять блокировку без учета текущего инициатора, то вы можете использовать метод forceRelease:
```php
Cache::lock('processing')->forceRelease();
```
