### App structure
```mermaid
graph LR
    PROJECT_FOLDER --> A[app<br>Весь основной код приложения] --> B[Console<br>Все что необходимо для обработки commands, стандартных и кастомных] --> C[Commands<br>Список всех команд]
    B --> D[Kernel.php<br>Регистрация кастомных commands]
    A --> E[Events<br>Входит в раздел слушатели и события. Слушатели и события объявляются в EventServiceProvider.php]
    A --> H[Http] --> C1[Controllers<br>Обработка запросов на отображение, создание, обновление и удаление]
    H --> C2[Middleware<br>MIDDLEWARE - ПРОМЕЖУТОЧНЫЙ СЛОЙ МЕЖДУ ВХОДЯЩИМ ЗАПРОСОМ И КОНТРОЛЛЕРОМ<br>Можно записать логи, добавить к ответу файлы куки и т.п.<br>Authenticate - вошел пользователь или не вошел<br>EncryptCookies - когда запрос с куками прилетает в наше приложение - он расшифровывает их, а на выходе - шифрует<br>PreventRequestsDuringMaintenance - находится ли наше приложение в режиме обслуживания при каком-либо запросе<br>php artisan down - включает режим обслуживания<br>RedirectIfAuthenticated - если юзер уже вошел в систему - перекидывает в личный кабинет<br>TrimStrings - если была отправлена форма регистрации, может быть такое что юзер прислал email с пробелом в конце<br>TrustHosts - хосты с которыми будет взаимодействовать приложение<br>TrustProxies - сервер-балансировщик распределяет все запросы поровну на сервера приложения<br>VerifyCsrfToken - защита от Csrf атаки. Это подделка межсайтовых запросов. Нужно соблюдать его при использовании форм POST, PUT, DELETE]
    H --> C3[Requests<br>Другая форма для правил валидации. Чтобы не писать логику валидации в контроллере - можем создать отдельный класс, <br>в котором в методе rules будут перечислены правила валидации]
    H --> C4[Kernel.php<br>Все что необходимо для обработки HTTP запросов<br>Настройка middleware - классов которые обрабатывают запрос, прежде чем он попадает в контроллер]
    A --> J[Jobs<br>Создание jobs. В sxope-ocean это bq_to_spanner и другие]
    A --> L[Listeners<br>Слушатели событий, объявляются в EventServiceProvider.php]
    A --> M[Mail<br>При запуске команды php artisan make:mail name. Служит для отправки уведомлений на почту]
    A --> M1[Models<br>Модели приложения, с помощью которых можно задать конфигурацию на относящийся к ним таблицы и взаимодействовать с ними]
    A --> P[Providers<br>Системные конфигурируемые настройки<br>AppServiceProvider - В методе 'boot' можно задать настройки для вьюх и т.д.<br>EventServiceProvider - Регистрация слушателей и событий<br>RouteServiceProvider - Можно задать новые пути для рутов, если мы хотим разделить их на несколько файлов]
    A --> R[Rules<br>Можно задать дополнительные правила валидации, которые потом сможем использовать в контроллере или в Requests]
    A --> S[Scopes<br>Можно задать условии, по котором при обращении к модели будут браться определенные данные. Например при запросах SELECT, UPDATE, DELETE]
    PROJECT_FOLDER --> B3[bootstrap] --> B4[app.php<br>Главный файл по запуску приложения. С этого файла начинается работа всего фреймворка<br>В переменную $app кладется экземпляр самого приложение, регистрируется HTTP и консольные ядра<br>Возвращается экземпляр приложения]
    B3 --> B5[cache<br>Этот каталог входит в gitignore, там фреймворк делает какие-то свои операции, которые не будут видны в репозитории]
    PROJECT_FOLDER --> C5[config<br>Просто множество файлов конфигурации. Можно создавать свои файлы конфигурации]
    PROJECT_FOLDER --> D1[database<br>Создаются файлы для работы с базой данных] --> D2[factories<br>Содержится конфиг для сидинга базы данных]
    D1 --> D3[migrations<br>Миграции к базе данных]
    D1 --> D4[seeders<br>Сиды для базы данных, которые используют фабрики]
    PROJECT_FOLDER --> L1[lang<br>Содержит настройку по языку проекта]
    PROJECT_FOLDER --> P1[public<br>Содержит в себе публичные файлы<br>Все запросы которые приходят от браузера должны попадать в файл index.php<br>Берем HTTP ядро и запускаем обработку запроса]
    PROJECT_FOLDER --> R1[resources] --> J1[css,jss<br>Исходные стили для страничек]
    R1 --> J2[views<br>Все странички сайта] --> J3[components<br>Работает как интерфейсы в ООП, только с небольшой реализацией и начальными параметрами]
    PROJECT_FOLDER --> R2[routes<br>Начальный файл маршрутизации web.php<br>Можно создавать свои файлы для маршрутизации]
    PROJECT_FOLDER --> S1[storage] --> S2[app] --> S3[public<br>Если пользователь загружает аватарку - она попадает сюда]
    S1 --> S4[framework<br>Закэшированные шаблоны для оптимизации]
    S1 --> S5[logs<br>Если возникает какая-то ошибка - можно поискать и найти ее там]
    PROJECT_FOLDER --> V[vendor<br>Пакеты и зависимости композера<br>Исходный код фреймворка в поддиректории laravel]
    PROJECT_FOLDER --> E1[.editorconfig<br>Параметры для редактора кода]
    PROJECT_FOLDER --> ENV[.env<br>Добавлен в .gitignore, переменная окружения]
    PROJECT_FOLDER --> ENV1[.env.example<br>Его нет в .gitignore, это просто шаблон .env]
    PROJECT_FOLDER --> GIT1[.gitignore<br>Добавляем файлы в .gitignore]
    PROJECT_FOLDER --> ARTISAN[artisan<br>Когда мы выполняем команду php artisan... берем app.php, берем консольное ядро Kernel и обрабатываем команду]
    PROJECT_FOLDER --> COMP[composer.json<br>Перечислены все пакеты которые нужны для работы нашего проекта]
    PROJECT_FOLDER --> COMP1[composer.lock<br>Фиксирование тех зависимостей и версий которые у нас остановлены]
    PROJECT_FOLDER --> PACKAGE[package.json<br>Для пакетов которые установлены через npm]
    PROJECT_FOLDER --> UNIT[phpunit.xml<br>Параметры для тестирования]
```

A --> C(Round Rect)
B --> D{Rhombus}
C --> D
